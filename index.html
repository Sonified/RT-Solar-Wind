<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ACE RT Visualization v1.2</title>
  <style>
    /* Basic reset and styling (same as your provided CSS) */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: Arial, sans-serif;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    #gui {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 340px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 10px;
      box-sizing: border-box;
      z-index: 10;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      transition: opacity 0.8s ease-in-out;
    }
    #gui.fade-out {
      opacity: 0;
      pointer-events: none;  /* Prevents interaction while faded out */
    }
    #gui:hover {
      opacity: 1;
      pointer-events: auto;
    }
    #controlsContainer h2 { 
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.2em;
      color: #0cf;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(0, 204, 255, 0.5);  /*/ Match the section header border
    }
    .control-group {
      margin-bottom: 2px !important;  /* Reduce from 4px to 3px */
    }
    .control-group label { 
      display: block; 
      margin-bottom: 1px;  /* Reduce from 2px to 1px */
      font-size: 0.9em;
    }
    .slider-container {
      position: relative;
      height: 16px;
      background: #333;
      border-radius: 8px;
      cursor: pointer;
    }
    .slider-fill {
      position: absolute;
      height: 100%;
      background: #0cf;
      border-radius: 10px;
      width: 50%; /* Initial fill */
    }
    .slider-value {
      margin-top: 2px;
      text-align: right;
      font-size: 0.8em;
    }
    button {
      width: 100%;
      padding: 6px;
      margin-bottom: 8px;
      background: #0cf;
      border: none;
      border-radius: 5px;
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { 
      background: #09a !important; 
    }
    button:active {
      background: #fff !important;
    }
    #plotCanvas {
      position: fixed !important;
      top: 25px !important;
      right: 20px !important;
      left: auto !important;
      width: 300px;
      height: 300px;
      background: rgba(0,0,0,0.7);
      border: 2px solid #0cf;
      border-radius: 5px;
      z-index: 10;
      padding: 5px;
      box-sizing: border-box;
    }
    #debug {
      position: fixed;
      bottom: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: #0f0;
      font-family: monospace;
      font-size: 12px;
      padding: 5px;
      max-width: 300px;
      max-height: 200px;
      overflow: auto;
      z-index: 20;
      transition: opacity 0.8s ease-in-out;
    }

    /* Add fade-out behavior for debug window */
    #gui.fade-out ~ #debug {
      opacity: 0;
      pointer-events: none;
    }
    #version-info {
        position: fixed;
        left: 10px;
        bottom: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-family: monospace;
        font-size: 11px;
        z-index: 10;
    }
    
    #creator-info {
        position: fixed;
        left: 220px;  /* Position it to the right of version info */
        bottom: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-family: monospace;
        font-size: 11px;
        z-index: 10;
    }
    #plotTitle {
      position: fixed !important;
      top: 10px !important;
      right: 20px !important;
      color: #0cf;
      font-family: Arial, sans-serif;
      font-size: 14px;
      z-index: 10;
      text-align: center;
      width: 300px;
    }
    #retryNowBtn:hover, #useHistoricalBtn:hover {
      background: #09a !important;
    }

    #retryNowBtn:active, #useHistoricalBtn:active {
      background: #fff !important;
    }

    .control-section {
      background: rgba(0, 30, 60, 0.3); /* More transparent blue tint */
      border-radius: 12px; /* More rounded corners */
      padding: 6px; /* Slightly less padding */
      margin-bottom: 10px; /* Slightly less margin */
    }

    .control-section.particles {
      background: rgba(30, 0, 60, 0.3); /* More transparent purple tint */
    }

    h3.section-header {
      margin: 0 0 6px 0; /* Less space below headers */
      padding: 3px 0; /* Less padding */
      font-size: 1.0em;
      color: #0cf;
      border-bottom: 1px solid rgba(0, 204, 255, 0.5); /* More transparent border */
    }

    /* Update the existing control-group spacing */
    .control-group {
      margin-bottom: 2px !important; /* Even less space between controls */
    }

    /* Update the spacing between sections */
    #controlsContainer > div.control-section {
      margin-bottom: 8px; /* Less space between sections */
    }
  </style>
  <script src="p5.min.js"></script>
</head>
<body>
  <div id="gui">
    <div id="controlsContainer">
      <h2>Controls</h2>
      <button id="playPauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>

      <div class="control-group">
        <label>Mode: <button id="modeBtn" style="width: auto; padding: 2px 8px; margin: 0 0 0 8px;">Stream All</button></label>
      </div>

      <div style="height: 12px;"></div>  <!-- Increased spacing -->

      <div class="control-section">
        <h3 class="section-header">Data Stream</h3>
        <div class="control-group">
          <label>Stream Rate</label>
          <div class="slider-container" data-min="0.1" data-max="10" data-step="0.1" data-value="4.00" id="dataRateSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="dataRateSliderValue">4.00/s</div>
        </div>

        <div class="control-group">
          <label>Stream Smoothing</label>
          <div class="slider-container" data-min="0" data-max="1" data-step="0.01" data-value="0.90" id="smoothingSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="smoothingSliderValue">90%</div>
        </div>
      </div>

      <div class="control-section particles">
        <h3 class="section-header">Particles</h3>
        <div class="control-group">
          <label>Relative Speed</label>
          <div class="slider-container" data-min="1" data-max="10" data-step="0.1" data-value="1.2" id="relSpeedSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="relSpeedSliderValue">1.2</div>
        </div>
        
        <div class="control-group">
          <label>Speed Sensitivity</label>
          <div class="slider-container" data-min="0" data-max="100" data-step="1" data-value="50" id="speedSensitivitySlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="speedSensitivitySliderValue">50%</div>
        </div>

        <div class="control-group">
          <label>Magnetic Field Vector Influence</label>
          <div class="slider-container" data-min="0" data-max="100" data-step="1" data-value="80" id="velocitySensitivitySlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="velocitySensitivitySliderValue">80%</div>
        </div>

        <div class="control-group">
          <label>Size</label>
          <div class="slider-container" data-min="1" data-max="30" data-step="1" data-value="17" id="sizeSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="sizeSliderValue">17</div>
        </div>

        <div class="control-group">
          <label>Max Count</label>
          <div class="slider-container" data-min="1" data-max="500" data-step="1" data-value="220" id="densitySlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="densitySliderValue">220</div>
        </div>

        <div class="control-group">
          <label>Base Generation Rate</label>
          <div class="slider-container" data-min="0" data-max="100" data-step="1" data-value="18" id="genRateSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="genRateSliderValue">18/s</div>
        </div>

        <div class="control-group">
          <label>Travel Distance</label>
          <div class="slider-container" data-min="1000" data-max="8000" data-step="100" data-value="3500" id="travelSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="travelSliderValue">4000</div>
        </div>

        <div class="control-group">
          <label>Spawn Area Size</label>
          <div class="slider-container" data-min="1" data-max="5" data-step="0.1" data-value="2.7" id="spawnSizeSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="spawnSizeSliderValue">2.7</div>
        </div>

        <div class="control-group">
          <label>Motion Trail Length</label>
          <div class="slider-container" data-min="0" data-max="30" data-step="1" data-value="23" id="trailLengthSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="trailLengthSliderValue">23</div>
        </div>

        <div class="control-group">
          <label>Motion Trail Size</label>
          <div class="slider-container" data-min="0" data-max="100" data-step="5" data-value="70" id="trailSizeSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="trailSizeSliderValue">70%</div>
        </div>

        <div class="control-group">
          <label>Fade In Time</label>
          <div class="slider-container" data-min="0" data-max="3" data-step="0.1" data-value="1.2" id="fadeInTimeSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="fadeInTimeSliderValue">1.2s</div>
        </div>

        <div class="control-group">
          <label>Motion Trail Size Tapering</label>
          <div class="slider-container" data-min="0" data-max="10" data-step="0.5" data-value="2" id="trailTaperSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="trailTaperSliderValue">2%</div>
        </div>

        <div class="control-group">
          <label>Motion Trail Opacity Tapering</label>
          <div class="slider-container" data-min="0" data-max="100" data-step="5" data-value="85" id="trailOpacityTaperSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="trailOpacityTaperSliderValue">85%</div>
        </div>

        <div class="control-group" style="display: none;">
          <label>Side Boundary</label>
          <div class="slider-container" data-min="0.1" data-max="3.0" data-step="0.1" data-value="0.1" id="boundarySlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="boundarySliderValue">0.1x</div>
        </div>

        <div class="control-group" style="display: none;">
          <label>Boundary Angle</label>
          <div class="slider-container" data-min="0" data-max="45" data-step="1" data-value="44" id="boundaryAngleSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="boundaryAngleSliderValue">44°</div>
        </div>

        <div class="control-group" style="display: none;">
          <label>Camera Opening</label>
          <div class="slider-container" data-min="0.01" data-max="1.0" data-step="0.1" data-value="0.0" id="cameraOpeningSlider">
            <div class="slider-fill"></div>
          </div>
          <div class="slider-value" id="cameraOpeningSliderValue">0.0x</div>
        </div>
      </div>
    </div>
  </div>

  <div id="plotTitle">ACE Near Real Time Data Stream</div>
  <div id="plotLabels" style="position: fixed !important; top: 48px !important; right: 325px !important; text-align: right; width: 100px; height: 300px; color: #0cf; font-family: sans-serif; font-size: 12px; z-index: 11; pointer-events: none;">
    <style>
      .plot-label {
        height: var(--plot-label-height, 42px);
        margin-bottom: 6px;
        display: flex;
        justify-content: flex-end;
        text-align: right;
      }
      .plot-label:last-child {
        height: var(--plot-label-last-height, 40px);
        margin-bottom: 20px;
      }
    </style>
    <div class="plot-label">Bx</div>
    <div class="plot-label">By</div>
    <div class="plot-label">Bz</div>
    <div class="plot-label">Speed</div>
    <div class="plot-label">Proton Dens</div>
    <div class="plot-label">Temp</div>
  </div>
  <canvas id="plotCanvas"></canvas>
  <canvas id="progressCanvas" style="position: fixed !important; top: 324px !important; right: 21px !important; left: auto !important; width: 295px; height: 4px; z-index: 10;"></canvas>
  <div id="loadingMessage" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #0cf; font-size: 24px; text-align: center; font-family: Arial, sans-serif; z-index: 100; display: none;">
    Attempting to load data, please check your internet connection...
    <div id="countdown" style="font-size: 18px; margin-top: 10px; color: #0cf8;">
      Retrying in <span id="countdownNumber">10</span>...
    </div>
    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
      <button id="retryNowBtn" style="padding: 8px 30px; background: #0cf; border: none; border-radius: 5px; color: black; cursor: pointer; font-size: 16px; height: 35px; width: 225px; transition: background 0.2s;">
        Retry Now
      </button>
      <button id="useHistoricalBtn" style="padding: 8px 30px; background: #0cf; border: none; border-radius: 5px; color: black; cursor: pointer; font-size: 16px; height: 35px; width: 225px; transition: background 0.2s;">
        Use Historical Data
      </button>
    </div>
  </div>
  </div>
  <div id="debug"></div>
  <div id="version-info">NOAA ACE Particle Visualization</div>
  <div id="creator-info" style="position: fixed; left: 220px; bottom: 10px; color: rgba(255, 255, 255, 0.5); font-family: monospace; font-size: 11px; z-index: 10;">
    Created by Robert Alexander: <a href="mailto:robert@auralab.io" style="color: rgba(255, 255, 255, 0.5); text-decoration: none; transition: color 0.2s;">robert@auralab.io</a>
  </div>

  <!-- Update both button styles -->
  <div style="position: fixed !important; top: 335px !important; right: 20px !important; width: 300px; display: flex; justify-content: center; gap: 10px; z-index: 10;">
    <button id="listenBtn" style="width: 110px; background: rgba(0, 204, 255, 0.2); border: 1px solid #0cf; color: #0cf; padding: 4px; border-radius: 5px; cursor: pointer; transition: background 0.2s;">
      Listen to Space
    </button>
    <button id="forecastBtn" style="width: 110px; background: rgba(0, 204, 255, 0.2); border: 1px solid #0cf; color: #0cf; padding: 4px; border-radius: 5px; cursor: pointer; transition: background 0.2s;">
      See Forecast
    </button>
  </div>

  <!-- Add the forecast modal -->
  <div id="forecastModal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
    background: rgba(0, 0, 0, 0.7); border: 1px solid #0cf; border-radius: 10px; padding: 20px; 
    max-width: 80%; max-height: 80%; overflow-y: auto; z-index: 1000;
    opacity: 0; transition: opacity 0.5s ease-in-out;">
    <div style="position: absolute; top: 10px; right: 10px; cursor: pointer; width: 24px; height: 24px; border: 2px solid #0cf; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: #0cf;">×</div>
    <h2 id="forecastTitle" style="color: #0cf; margin-top: 0; margin-bottom: 5px;"></h2>
    <h3 id="forecastDate" style="color: #0cf; opacity: 0.8; font-size: 0.9em; margin-top: 0; margin-bottom: 20px;"></h3>
    <div id="forecastContent" style="color: #fff; font-family: monospace; white-space: pre-wrap;"></div>
  </div>

  <!-- Update the right position from 115px to 95px -->
  <div id="noDataMessage" style="position: fixed !important; top: 170px !important; right: 100px !important; color: #0cf; font-family: Arial, sans-serif; font-size: 16px; z-index: 11; pointer-events: none; display: none;">
    No data loaded...
  </div>

<script>
// Comment out debug logging statements
function clog(...args) {
    // console.log("debug:", ...args);
}

// ---------- Custom Slider Functions (Reusable) ----------
function initSlider(id) {
  const slider = document.getElementById(id);
  const fill = slider.querySelector('.slider-fill');
  const valueDisplay = document.getElementById(id + "Value");
  const min = parseFloat(slider.dataset.min);
  const max = parseFloat(slider.dataset.max);
  const step = parseFloat(slider.dataset.step);
  let value = parseFloat(slider.dataset.value);

  function updateSlider(newVal) {
    value = Math.min(max, Math.max(min, newVal)); // Clamp value
    slider.dataset.value = value.toFixed(2);
    const percentage = ((value - min) / (max - min)) * 100;
    fill.style.width = percentage + '%';
    
    // Format display value based on slider type
    let displayValue;
    if (id.includes("Sensitivity") || id === "trailSizeSlider" || id === "trailTaperSlider" || id === "trailOpacityTaperSlider") {
      displayValue = Math.round(value) + "%";
    } else if (id === "smoothingSlider") {
      displayValue = Math.round(value * 100) + "%";
    } else if (id === "relSpeedSlider") {
      displayValue = value.toFixed(1);
    } else if (id === "dataRateSlider") {
      displayValue = value.toFixed(2) + "/s";
    } else if (id === "spawnSizeSlider" || id === "boundarySlider" || id === "cameraOpeningSlider") {  // Add cameraOpeningSlider here
      displayValue = value.toFixed(1) + "x";
    } else if (id === "fadeInTimeSlider") {
      displayValue = value.toFixed(1) + "s";
    } else if (id === "genRateSlider") {
      displayValue = Math.round(value) + "/s";
    } else {
      displayValue = Math.round(value);
    }
    valueDisplay.textContent = displayValue;
  }
  updateSlider(value);

  slider.addEventListener('mousedown', (e) => {
    e.preventDefault();
    const rect = slider.getBoundingClientRect();

    function onMove(e) {
      let pos = e.clientX - rect.left;
      let perc = Math.max(0, Math.min(1, pos / rect.width));
      let newVal = min + perc * (max - min);
      newVal = Math.round(newVal / step) * step; // Snap to step
      updateSlider(newVal);
    }

    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}

function getSliderValue(id) {
  return parseFloat(document.getElementById(id).dataset.value);
}


// ---------- Global Variables ----------
let particles = [];
let playing = true;
let currentRecordIndex = 0;

// UI Control Variables (with defaults)
let dataRate;
let relSpeed;
let speedSensitivity;
let velocitySensitivity;
let smoothingFactor;
let particleSize;
let densityFactor;
let travelDistance;
let particleGenRate = 0;
let lastParticleTime = 0;

// Data and Smoothed Parameters
let simDir;
let simSpeed = 1;
let simDensity = 100;
let simTemperature = 0;
let simDateStr = "N/A";
let currentDir;
let currentSpeed = 1;
let currentTemperature = 30000;

// Data Arrays
let magDataRaw = [];
let swepamDataRaw = [];
let magRecords = [];
let swepamRecords = [];
let totalRecords = 0;

// Plotting
let bxHistory = [], byHistory = [], bzHistory = [];
let speedHistory = [];
let densityHistory = [];
let temperatureHistory = [];
const maxHistory = 200;
const plotColors = {
  "Bx": "#0cf", "By": "#fc0", "Bz": "#f0c",
  "Vel": "#0f0", "Dens": "#ff0", "Temp": "#f0f"
};

// Add these global variables
let minTemp, maxTemp;
let spawnAreaSize;
let particlesCreatedTimes = []; // Array to track ALL particle creations (new OR respawn)
const RATE_WINDOW = 50; // 50ms window for rate limiting
let streamMode = 'all'; // 'all' or 'recent'

// Add a new global variable for accumulation
let particleAccumulator = 0;

// Add these global variables
let respawnQueue = [];  // Line of particles waiting to get back in
let nextRespawnTime = 0;

// Add to global variables
let lastRespawnTime = 0;
let respawnInterval = 0;

// Add to global variables
let particlesPassedThisSecond = 0;
let lastCounterReset = 0;

// Replace the spawner with this improved version
let spawner = {
    spawnHistory: [],  // Track spawns in the last second
    lastSpawnTime: 0,  // Track last spawn time
    lastSecondMark: 0, // Track full seconds
    deathCount: 0,     // Track deaths in current second
    
    update() {
        let currentTime = millis();
        let targetRate = getSliderValue("genRateSlider");
        let maxParticles = getSliderValue("densitySlider");
        
        // Check if a full second has passed
        let currentSecond = Math.floor(currentTime/1000);
        let lastSecond = Math.floor(this.lastSecondMark/1000);
        
        if (currentSecond > lastSecond) {
            // console.log(`%c🕐 ======= NEW SECOND ${currentSecond} =======\n   Active Particles: ${particles.length}/${maxParticles}\n   Spawned: ${this.spawnHistory.length}\n   Deaths: ${this.deathCount}\n   Net Change: ${this.spawnHistory.length - this.deathCount}`, 
                // 'font-size: 16px; font-weight: bold; color: #0cf;');
            
            // Log all particle positions
            // console.log("Particle Positions:");
            particles.forEach((p, i) => {
                // clog(`  Particle ${i}: x=${p.pos.x.toFixed(1)}, y=${p.pos.y.toFixed(1)}, z=${p.pos.z.toFixed(1)}`);
            });
            
            this.lastSecondMark = currentTime;
            this.spawnHistory = [];
            this.deathCount = 0;
        }
        
        // Clean history - only keep spawns from last second
        this.spawnHistory = this.spawnHistory.filter(time => 
            currentTime - time < 1000
        );
        
        let minInterval = 1000 / targetRate;
        
        // STRICT particle count enforcement
        if (particles.length >= maxParticles) {
            return; // Don't spawn if we're at or over limit
        }
        
        if (this.spawnHistory.length < targetRate && 
            currentTime - this.lastSpawnTime >= minInterval) {
            
            particles.push(new Particle(getSliderValue("travelSlider")));
            this.spawnHistory.push(currentTime);
            this.lastSpawnTime = currentTime;
            
            // clog(`[SPAWN] +1 particle (${particles.length}/${maxParticles}, Rate: ${this.spawnHistory.length}/${targetRate}/s)`);
        }
    }
};

// Modify the existing Particle class update method
class Particle {
  constructor(travelDist) {
    let spawnAreaSize = getSliderValue("spawnSizeSlider");
    this.pos = createVector(
      random(-width * spawnAreaSize / 2, width * spawnAreaSize / 2),
      random(-height * spawnAreaSize / 2, height * spawnAreaSize / 2),
      -travelDist
    );
    this.alpha = 0;
    this.baseVel = createVector(0,0,0);
    this.dataVel = createVector(0,0,0);
    this.birthTime = millis();
    this.birthTemp = simTemperature;
    this.birthDir = currentDir.copy();
    this.birthSpeed = currentSpeed;
    
    // Initialize trail with fixed length (no scaling)
    let maxTrail = getSliderValue("trailLengthSlider");
    this.trail = new Array(Math.round(maxTrail)).fill(this.pos.copy());
  }

  update(dir, speed, relSpeed, speedSens, magFieldSens) {
    // Normal update code...
    this.baseVel = createVector(0, 0, relSpeed * 10);
    this.dataVel = this.birthDir.copy().mult(this.birthSpeed * speedSens * 0.05);
    this.vel = p5.Vector.lerp(this.baseVel, this.dataVel.add(this.baseVel), magFieldSens);
    
    // Update position first
    this.pos.add(this.vel);
    
    // Update trail
    this.trail.push(this.pos.copy());
    while (this.trail.length > getSliderValue("trailLengthSlider")) {
      this.trail.shift();
    }
    
    // Update alpha
    let fadeInTime = getSliderValue("fadeInTimeSlider") * 1000;
    let timeSinceBirth = millis() - this.birthTime;
    this.alpha = map(timeSinceBirth, 0, fadeInTime, 0, 255);
    this.alpha = constrain(this.alpha, 0, 255);

    // Check termination conditions in order
    let travelDist = getSliderValue("travelSlider");
    
    // 1. Check camera plane first
    if (this.pos.z > 5) {
      return true;
    }
    
    // 2. Check back wall
    if (this.pos.z < -travelDist) {
      return true;
    }
    
    // 3. Check side boundaries with angle
    let spawnAreaSize = getSliderValue("spawnSizeSlider");
    let boundaryLimit = getSliderValue("boundarySlider");
    let boundaryAngle = getSliderValue("boundaryAngleSlider");
    let cameraOpening = getSliderValue("cameraOpeningSlider");
    let baseWidth = width * spawnAreaSize / 2;
    let progress = (-this.pos.z) / travelDist;
    let angleRad = boundaryAngle * PI / 180;
    let angleExpansion = -this.pos.z * tan(angleRad);
    let currentWidth = (baseWidth * cameraOpening) + (baseWidth * (boundaryLimit - cameraOpening) * progress) + angleExpansion;
    
    if (Math.abs(this.pos.x) > currentWidth || Math.abs(this.pos.y) > currentWidth) {
      return true;
    }
    
    return false;
  }

  reset() {
      let spawnAreaSize = getSliderValue("spawnSizeSlider");
      this.pos = createVector(
          random(-width * spawnAreaSize / 2, width * spawnAreaSize / 2),
          random(-height * spawnAreaSize / 2, height * spawnAreaSize / 2),
          -travelDistance
      );
      this.alpha = 0;
      this.birthTime = millis();
      this.birthTemp = simTemperature;
      this.birthDir = currentDir.copy();  // Update direction on reset
      this.birthSpeed = currentSpeed;
      
      // Clear the trail (no scaling)
      let maxTrail = getSliderValue("trailLengthSlider");
      this.trail = new Array(Math.round(maxTrail)).fill(this.pos.copy());
  }

  show(size) {
      let trailLength = this.trail.length;
      if (trailLength > 0) {
          let trailSizePercent = getSliderValue("trailSizeSlider") / 100;
          let taperPercent = getSliderValue("trailTaperSlider") / 100;
          let opacityTaperPercent = getSliderValue("trailOpacityTaperSlider") / 100;
          
          for (let i = 0; i < trailLength; i++) {
              let pos = this.trail[i];
              if (pos.z > 0) continue;  // Skip if behind camera
              
              let progress = i / trailLength;  // 0 at start, 1 at end
              let trailAlpha = this.alpha * (progress + (1 - opacityTaperPercent));
              let sizeReduction = 1.0 - (taperPercent * (trailLength - i - 1));
              let pointSize = size * trailSizePercent * sizeReduction;
              
              if (pointSize > 0) {
                  push();
                  translate(pos.x, pos.y, pos.z);
                  let col = this.mapTemperatureToColor(this.birthTemp);
                  noStroke();
                  fill(red(col), green(col), blue(col), trailAlpha * 0.5);
                  sphere(pointSize, 3, 3);
                  pop();
              }
          }
      }

      // Draw the main particle if not behind camera
      if (this.pos.z <= 0) {
          push();
          translate(this.pos.x, this.pos.y, this.pos.z);
          let col = this.mapTemperatureToColor(this.birthTemp);
          noStroke();
          fill(red(col), green(col), blue(col), this.alpha);
          sphere(size);
          pop();
      }
  }
    mapTemperatureToColor(temp) {
        // NEW COLOR MAP: Dark Blue -> Red -> Yellow -> White
        let range = maxTemp - minTemp;
        let firstThird = minTemp + range / 3;
        let secondThird = minTemp + (2 * range) / 3;
        let col;

        if (temp < firstThird) {
            // Dark Blue to Red
            col = lerpColor(
                color(0, 0, 139),     // Dark Blue
                color(255, 0, 0),     // Red
                map(temp, minTemp, firstThird, 0, 1)
            );
        } else if (temp < secondThird) {
            // Red to Yellow
            col = lerpColor(
                color(255, 0, 0),     // Red
                color(255, 255, 0),   // Yellow
                map(temp, firstThird, secondThird, 0, 1)
            );
        } else {
            // Yellow to White
            col = lerpColor(
                color(255, 255, 0),   // Yellow
                color(255, 255, 255), // White
                map(temp, secondThird, maxTemp, 0, 1)
            );
        }
        return col;
    }
}

// ---------- Plotting Functions ----------
function updateHistory(arr, value) {
  arr.push(value);
  if (arr.length > maxHistory) arr.shift();
}

function updatePlots() {
  let canvas = document.getElementById("plotCanvas");
  let ctx = canvas.getContext("2d");
  
  // Make sure we're using the right dimensions
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Check for no data
  if (!magRecords || !swepamRecords || magRecords.length === 0 || swepamRecords.length === 0) {
    // Fill background
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw "No data loaded..." message with better positioning
    ctx.fillStyle = "#0cf";
    ctx.font = "16px Arial"; // Slightly larger font
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("No data loaded...", canvas.width/2, canvas.height/2);
    
    // Draw border to match normal plot style
    ctx.strokeStyle = "#0cf";
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, canvas.width, canvas.height);
    return;
  }

  let numPlots = 6;
  let gap = 5;
  let plotHeight = (canvas.height - (numPlots - 1) * gap) / numPlots;

  drawPlot(ctx, bxHistory, 0, 0 * (plotHeight + gap), canvas.width, plotHeight, "Bx");
  drawPlot(ctx, byHistory, 0, 1 * (plotHeight + gap), canvas.width, plotHeight, "By");
  drawPlot(ctx, bzHistory, 0, 2 * (plotHeight + gap), canvas.width, plotHeight, "Bz");
  drawPlot(ctx, speedHistory, 0, 3 * (plotHeight + gap), canvas.width, plotHeight, "Vel");
  drawPlot(ctx, densityHistory, 0, 4 * (plotHeight + gap), canvas.width, plotHeight, "Dens");
  drawPlot(ctx, temperatureHistory, 0, 5 * (plotHeight + gap), canvas.width, plotHeight, "Temp");

  // Draw progress indicator on separate canvas
  let progressCanvas = document.getElementById("progressCanvas");
  let pctx = progressCanvas.getContext("2d");
  progressCanvas.width = progressCanvas.clientWidth;
  progressCanvas.height = progressCanvas.clientHeight;
  
  let progress = currentRecordIndex / totalRecords;
  pctx.clearRect(0, 0, progressCanvas.width, progressCanvas.height);
  pctx.beginPath();
  pctx.strokeStyle = 'white';
  pctx.lineWidth = 2;
  pctx.moveTo(0, progressCanvas.height/2);
  pctx.lineTo(progressCanvas.width * progress, progressCanvas.height/2);
  pctx.stroke();
}

function drawPlot(ctx, dataArray, x, y, w, h, label) {
  ctx.fillStyle = "rgba(0,0,0,0.8)";
  ctx.fillRect(x, y, w, h);

  // Draw divider line after each plot (except the last one)
  if (label !== "Temp") {
    ctx.strokeStyle = "rgba(0, 204, 255, 0.4)"; // #0cf at 40% opacity
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y + h + 2);  // 2px gap from plot bottom
    ctx.lineTo(x + w, y + h + 2);
    ctx.stroke();
  }

  if (dataArray.length < 2) return;
  
  let range = computeRange(dataArray);
  let minVal = range.min;
  let maxVal = range.max;
  if (maxVal === minVal) { maxVal += 1; minVal -= 1; }

  ctx.strokeStyle = plotColors[label] || "white";
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i = 0; i < dataArray.length; i++) {
    let dx = x + (i / (maxHistory - 1)) * w;
    let dy = y + h - ((dataArray[i] - minVal) / (maxVal - minVal)) * h;
    if (i === 0) ctx.moveTo(dx, dy);
    else ctx.lineTo(dx, dy);
  }
  ctx.stroke();

  ctx.fillStyle = plotColors[label] || "white";
  ctx.font = "12px sans-serif";
  ctx.textAlign = "right";
  let value = dataArray[dataArray.length-1];
  let text;
  
  // Add handling for magnetic field values
  if (label === "Bx" || label === "By" || label === "Bz") {
    text = `${value.toFixed(2)}`;  // Just show the number with 2 decimal places
  } else if (label === "Vel") {
    text = `${value.toFixed(2)} km/s`;
  } else if (label === "Dens") {
    text = `${value.toFixed(2)} p/cc`;
  } else if (label === "Temp") {
    text = `${Math.round(value).toLocaleString()} K`;
  }
  
  ctx.fillText(text, x + w - 5, y + 15);
}

// ---------- Particle Management ----------
function adjustParticleCount(densityFactor) {
    let desiredCount = floor(densityFactor);
    if (desiredCount < particles.length) {
        particles.splice(desiredCount); // Remove excess particles
    }
}

function updateParticles() {
    let currentTime = millis();
    
    // Clean up old creation times more frequently
    particlesCreatedTimes = particlesCreatedTimes.filter(time => 
        currentTime - time < RATE_WINDOW
    );

    // Calculate fractional particles for this window
    let ratePerWindow = (particleGenRate * RATE_WINDOW) / 1000;  // Remove Math.max(1, ...)
    particleAccumulator += ratePerWindow;

    // Only generate if we've accumulated at least one particle
    while (particleGenRate > 0 && 
           particles.length < densityFactor && 
           particleAccumulator >= 1) {
        
        particles.push(new Particle(travelDistance));
        particlesCreatedTimes.push(currentTime);
        particleAccumulator -= 1;  // Subtract one particle worth
    }

    // Update existing particles
    for (let i = particles.length - 1; i >= 0; i--) {
        if (particles[i].update(currentDir, currentSpeed, relSpeed, speedSensitivity, velocitySensitivity)) {
            particles.splice(i, 1);
        }
    }
}

// ---------- p5.js Functions ----------
let countdownInterval;

let retryDelay = 10; // Initial delay in seconds

function startCountdown() {
  let count = retryDelay;
  const countdownElement = document.getElementById('countdownNumber');
  
  clearInterval(countdownInterval);
  countdownInterval = setInterval(() => {
    count--;
    countdownElement.textContent = count;
    
    if (count <= 0) {
      clearInterval(countdownInterval);
      retryDelay += 10; // Increase delay for next retry
      count = retryDelay;
      countdownElement.textContent = count;
      preload(); // Retry loading
    }
  }, 1000);
}

async function loadHistoricalData() {
  try {
    // Change the message text first
    document.getElementById('noDataMessage').textContent = "Historical data";
    document.getElementById('noDataMessage').style.display = "block";

    const [magResponse, swepamResponse] = await Promise.all([
      fetch('ace-magnetometer.txt'),
      fetch('ace-swepam.txt')
    ]);

    if (!magResponse.ok || !swepamResponse.ok) {
      throw new Error('Failed to load historical data files');
    }

    const [magText, swepamText] = await Promise.all([
      magResponse.text(),
      swepamResponse.text()
    ]);

    magDataRaw = magText.split('\n');
    swepamDataRaw = swepamText.split('\n');
    
    magRecords = parseMagData(magDataRaw);
    swepamRecords = parseSWEData(swepamDataRaw);
    totalRecords = Math.min(magRecords.length, swepamRecords.length);
    
    clearInterval(countdownInterval);
    document.getElementById('loadingMessage').style.display = 'none';
  } catch (error) {
    // On error, revert the message back
    document.getElementById('noDataMessage').textContent = "No data loaded...";
    alert("Failed to load historical data. Please try again later.");
  }
}

// Add these global variables at the top
let cachedForecastContent = null;
let cachedOutlookContent = null;
let cachedForecastDate = null;
let cachedOutlookTitle = null;

// Add this function to fetch forecast data
async function fetchForecastData() {
  try {
    const [forecastResponse, outlookResponse] = await Promise.all([
      fetch('https://services.swpc.noaa.gov/text/weekly.txt'),
      fetch('https://services.swpc.noaa.gov/text/advisory-outlook.txt')
    ]);
    
    const [forecastText, outlookText] = await Promise.all([
      forecastResponse.text(),
      outlookResponse.text()
    ]);
    
    // Process forecast
    const forecastStart = forecastText.indexOf('Forecast of Solar and Geomagnetic Activity');
    cachedForecastDate = forecastText.substr(forecastStart).match(/(\d+ \w+ - \d+ \w+ \d+)/)[1];
    cachedForecastContent = forecastText.substr(forecastStart).split('\n').slice(2).join('\n');
    
    // Process outlook
    const outlookStart = outlookText.indexOf('Outlook For');
    const outlookLines = outlookText.substr(outlookStart).split('\n');
    cachedOutlookTitle = outlookLines[0];
    cachedOutlookContent = outlookLines.slice(2, 3).join('\n').trim();
  } catch (error) {
    console.error('Error pre-fetching forecast:', error);
  }
}

// Modify preload to include forecast fetch
async function preload() {
  console.log("Starting preload...");
  try {
    // Fetch both ACE data and forecast data in parallel
    await Promise.all([
      (async () => {
        const [magResponse, swepamResponse] = await Promise.all([
          fetch('https://services.swpc.noaa.gov/text/ace-magnetometer.txt'),
          fetch('https://services.swpc.noaa.gov/text/ace-swepam.txt')
        ]);

        const [magText, swepamText] = await Promise.all([
          magResponse.text(),
          swepamResponse.text()
        ]);

        magDataRaw = magText.split('\n');
        swepamDataRaw = swepamText.split('\n');
        
        magRecords = parseMagData(magDataRaw);
        swepamRecords = parseSWEData(swepamDataRaw);
        
        // Update total records
        totalRecords = Math.min(magRecords.length, swepamRecords.length);
        
        // Find first valid record
        for (let i = 0; i < magRecords.length; i++) {
          if (magRecords[i].Bx !== -999.9) {
            currentRecordIndex = i;
            break;
          }
        }

        // Set up auto-refresh
        setInterval(async () => {
          const [newMagResponse, newSwepamResponse] = await Promise.all([
            fetch('https://services.swpc.noaa.gov/text/ace-magnetometer.txt'),
            fetch('https://services.swpc.noaa.gov/text/ace-swepam.txt')
          ]);
          
          const [newMagText, newSwepamText] = await Promise.all([
            newMagResponse.text(),
            newSwepamResponse.text()
          ]);

          magDataRaw = newMagText.split('\n');
          swepamDataRaw = newSwepamText.split('\n');
          magRecords = parseMagData(magDataRaw);
          swepamRecords = parseSWEData(swepamDataRaw);
          totalRecords = Math.min(magRecords.length, swepamRecords.length);
        }, 60000);

        clearInterval(countdownInterval);
        document.getElementById('loadingMessage').style.display = 'none';
      })(),
      fetchForecastData() // Fetch forecast data in parallel
    ]);

  } catch (error) {
    console.error("Error in preload:", error);
    document.getElementById('loadingMessage').style.display = "block";
    document.getElementById('noDataMessage').style.display = "block";
    startCountdown();
  }
}

function setup() {
  setAttributes('alpha', true);
  createCanvas(windowWidth, windowHeight, WEBGL);
  frameRate(60);

  // Initialize UI values (important to do this *before* creating particles)
  dataRate = getSliderValue("dataRateSlider");
  relSpeed = getSliderValue("relSpeedSlider");
  speedSensitivity = getSliderValue("speedSensitivitySlider") / 100; // Convert percentage to 0-1 range
  velocitySensitivity = getSliderValue("velocitySensitivitySlider")/100;
  smoothingFactor = getSliderValue("smoothingSlider");
  particleSize = getSliderValue("sizeSlider");
  densityFactor = getSliderValue("densitySlider");
  travelDistance = getSliderValue("travelSlider");
  particleGenRate = getSliderValue("genRateSlider");

  // Print termination conditions
  let cameraBuffer = 5;  // Allow particles to go slightly past camera for trail visibility
  let spawnAreaSize = getSliderValue("spawnSizeSlider");
  let boundaryLimit = getSliderValue("boundarySlider");
  let sideLimit = width * spawnAreaSize * boundaryLimit / 2;
  let travelDist = getSliderValue("travelSlider");
  
  // console.log("%c=== Particle Termination Conditions ===", 'font-size: 14px; font-weight: bold; color: #f00;');
  // console.log(`Camera Position: (0, 0, 0) looking down -Z axis`);
  // console.log(`Spawn Location: x=random(±${sideLimit.toFixed(0)}), y=random(±${sideLimit.toFixed(0)}), z=${-travelDist} (back wall)`);
  // console.log(`Movement Direction: Particles move from back wall (z=${-travelDist}) toward camera (z=0)`);
  // console.log(`1. Front wall (camera): z > ${cameraBuffer} units (allows trails to be visible)`);
  // console.log(`2. Side boundaries: Angled walls from ±${(width * spawnAreaSize/2).toFixed(0)} at camera to ±${sideLimit.toFixed(0)} at back (${boundaryLimit}x)`);
  // console.log(`3. Back wall: z < ${-travelDist} units (spawn plane)`);
  // console.log("=================================");

  // Parse data
  if (magDataRaw && magDataRaw.length > 0) {
    magRecords = parseMagData(magDataRaw);
    for (let i = 0; i < magRecords.length; i++) {
      if (magRecords[i].Bx !== -999.9) {
        currentRecordIndex = i;
        break;
      }
    }
  } else { clog("ERROR: No magnetometer data."); }
  if (swepamDataRaw && swepamDataRaw.length > 0) {
    swepamRecords = parseSWEData(swepamDataRaw);
  } else { clog("ERROR: No swepam data."); }
  totalRecords = min(magRecords.length, swepamRecords.length);
  clog("Total records:", totalRecords);

  currentDir = createVector(1, 0, 0);
  currentSpeed = 1;
  currentTemperature = 30000;

  // Instead of creating all particles at once, start with an empty array
  particles = [];

    // Initialize sliders
    initSlider("dataRateSlider");
    initSlider("relSpeedSlider");
    initSlider("speedSensitivitySlider");
    initSlider("velocitySensitivitySlider");
    initSlider("smoothingSlider");
    initSlider("sizeSlider");
    initSlider("densitySlider");
    initSlider("travelSlider");
    initSlider("genRateSlider");
    initSlider("spawnSizeSlider");
    initSlider("trailLengthSlider");
    initSlider("fadeInTimeSlider");
    initSlider("trailSizeSlider");
    initSlider("trailTaperSlider");
    initSlider("boundarySlider");
    initSlider("boundaryAngleSlider");
    initSlider("cameraOpeningSlider");
    initSlider("trailOpacityTaperSlider");
}


function draw() {
  background(0);
  
  // Simple check - if no data, just return
  if (!magRecords || !swepamRecords || magRecords.length === 0 || swepamRecords.length === 0) {
    return;
  }

  // Update control variables
  dataRate = getSliderValue("dataRateSlider");
  relSpeed = getSliderValue("relSpeedSlider");
  speedSensitivity = getSliderValue("speedSensitivitySlider") / 100; // 0-1 range
  velocitySensitivity = getSliderValue("velocitySensitivitySlider")/100;
  smoothingFactor = getSliderValue("smoothingSlider");
  particleSize = getSliderValue("sizeSlider");
  densityFactor = getSliderValue("densitySlider");
  travelDistance = getSliderValue("travelSlider");
  particleGenRate = getSliderValue("genRateSlider");

  // Get data for the current frame
  if (magRecords.length > 0) {
    let idx = floor(currentRecordIndex);
    let magRec = magRecords[idx];
    if (magRec) {
      let bx = (magRec.Bx !== -999.9) ? magRec.Bx : currentDir.x;
      let by = (magRec.By !== -999.9) ? magRec.By : currentDir.y;
      let bz = (magRec.Bz !== -999.9) ? magRec.Bz : currentDir.z;
      simDir = createVector(bx, by, bz).normalize();
      simDateStr = nf(magRec.year, 4) + "-" + nf(magRec.month, 2) + "-" + nf(magRec.day, 2) + " " + magRec.time;
      updateHistory(bxHistory, bx);
      updateHistory(byHistory, by);
      updateHistory(bzHistory, bz);
    }
  }
  if (swepamRecords.length > 0) {
    let idx = floor(currentRecordIndex);
    let sweRec = swepamRecords[idx];
    if (sweRec) {
        // Apply clipping to the values
        simSpeed = (sweRec.bulkSpeed !== -9999.9) ? 
          clipToRange(sweRec.bulkSpeed, FIXED_RANGES.SPEED.min, FIXED_RANGES.SPEED.max, true) : currentSpeed;
        
        simDensity = (sweRec.protonDensity !== -9999.9) ? 
          clipToRange(sweRec.protonDensity, FIXED_RANGES.DENSITY.min, FIXED_RANGES.DENSITY.max) : simDensity;
        
        simTemperature = (sweRec.ionTemp !== -1.00e+05) ? 
          clipToRange(sweRec.ionTemp, FIXED_RANGES.TEMPERATURE.min, FIXED_RANGES.TEMPERATURE.max) : currentTemperature;
        
        updateHistory(speedHistory, simSpeed);
        updateHistory(densityHistory, simDensity);
        updateHistory(temperatureHistory, simTemperature);
    }
  }

  // Smoothing
  let updateFactor = lerp(1, 0.05, smoothingFactor);
  currentDir = p5.Vector.lerp(currentDir, simDir, updateFactor);
  currentSpeed = lerp(currentSpeed, simSpeed, updateFactor);
  currentTemperature = lerp(currentTemperature, simTemperature, smoothingFactor);

  // Adjust particle count
  adjustParticleCount(densityFactor);

  // Update and draw particles
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    
    // Update particle
    if (p.update(currentDir, currentSpeed, relSpeed, speedSensitivity, velocitySensitivity)) {
        particles.splice(i, 1);  // Remove if update returns true
        continue;
    }
    
    // Draw particle
    p.show(particleSize);
  }

  // Generate new particles based on rate
  spawner.update();

  // p5.js drawing
  background(0);
  camera(0, 0, 0, 0, 0, -1000, 0, 1, 0); // Look down -Z axis

  // Update the record index advancement in the draw function
  if (playing && totalRecords > 0) {
    if (streamMode === 'all') {
      currentRecordIndex += dataRate / 60; // Advance by dataRate records per second
      if (currentRecordIndex >= totalRecords) currentRecordIndex = 0;
    } else {
      // Find most recent valid data point
      let idx = totalRecords - 1;
      while (idx > 0 && 
             (magRecords[idx].Bx === -999.9 || 
              magRecords[idx].By === -999.9 || 
              magRecords[idx].Bz === -999.9 || 
              swepamRecords[idx].bulkSpeed === -9999.9 || 
              swepamRecords[idx].protonDensity === -9999.9 || 
              swepamRecords[idx].ionTemp === -1.00e+05)) {
        idx--;
      }
      currentRecordIndex = idx;
    }
  }

  // Update and draw particles with rate-limited respawning
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    
    // Check if particle needs to reset
    if (p.pos.z >= travelDistance) {  // Particle hit the far camera plane
        particles.splice(i, 1);
        // clog(`Removed particle at camera plane (Count: ${particles.length})`);
    } else {
      p.show(particleSize);
    }
  }
    updatePlots(); // Update the plots.

  // Replace the existing debug logging with more detailed particle system status
  if (frameCount % 100 === 0) {
    // clog("=== Particle System Status ===");
    // clog(`Generation Rate: ${particleGenRate} particles/sec`);
    // clog(`Current Particle Count: ${particles.length}`);
    // clog(`Target Count: ${densityFactor}`);
    // clog(`Last Generation: ${millis() - lastParticleTime}ms ago`);
    // clog(`Current Frame: ${frameCount}`);
    // clog(`Record: ${floor(currentRecordIndex)} Date: ${simDateStr}`);
    // clog("===========================");
  }

    let dbgText = "Date/Time: " + simDateStr + " (UTC)<br>" +
        "Record: " + floor(currentRecordIndex) + " / " + totalRecords + "<br>" +
        "Bx, By, Bz: " + ((magRecords.length > 0 && magRecords[floor(currentRecordIndex)]) ?
            magRecords[floor(currentRecordIndex)].Bx.toFixed(2) + ", " +
            magRecords[floor(currentRecordIndex)].By.toFixed(2) + ", " +
            magRecords[floor(currentRecordIndex)].Bz.toFixed(2) : "N/A") + "<br>" +
        "Speed: " + simSpeed.toFixed(2) + " km/s<br>" +
        "Proton Dens: " + simDensity.toFixed(2) + " p/cc<br>" +
        "Temp: " + simTemperature.toFixed(2) + " K<br>" +
        "Data Rate: " + dataRate.toFixed(2) + " rec/sec, Rel Speed: " + relSpeed.toFixed(2) + "<br>" +
        "Speed Sens: " + (speedSensitivity * 100).toFixed(0) + "%, Mag Field Sens: " + (velocitySensitivity*100).toFixed(0) + "%<br>"+
        "Smoothing: " + smoothingFactor.toFixed(2) + ", Particle Size: " + particleSize.toFixed(2) + "<br>" +
        "Active Particles: " + particles.length + "<br>";

    document.getElementById("debug").innerHTML = dbgText;

  if (SHOW_BOUNDARY_VISUALIZATION) {
    drawBoundary();  // Only draw boundary if enabled
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight, WEBGL);
  // clog("Window resized:", windowWidth, windowHeight);
}

// ---------- UI Button Listeners ----------
document.getElementById("playPauseBtn").addEventListener("click", () => {
  playing = !playing;
  if (playing) {
    document.getElementById("playPauseBtn").textContent = "Pause";
    loop();
  } else {
    document.getElementById("playPauseBtn").textContent = "Play";
    noLoop();
  }
});
document.getElementById("resetBtn").addEventListener("click", () => {
  // Reset visualization state
  particles = [];
  currentRecordIndex = 0;
  currentDir = createVector(1,0,0);
  currentSpeed = 1;
  currentTemperature = 30000;

  // Reset all sliders to their default values
  const defaultValues = {
    "dataRateSlider": 4.00,
    "smoothingSlider": 0.90,
    "relSpeedSlider": 1.2,
    "speedSensitivitySlider": 50,
    "velocitySensitivitySlider": 80,
    "sizeSlider": 17,
    "densitySlider": 220,
    "genRateSlider": 18,
    "travelSlider": 4000,
    "spawnSizeSlider": 3.0,
    "trailLengthSlider": 23,
    "trailSizeSlider": 70,
    "fadeInTimeSlider": 1.7,
    "trailTaperSlider": 2,
    "trailOpacityTaperSlider": 85
  };

  // Update each slider
  Object.entries(defaultValues).forEach(([sliderId, value]) => {
    const slider = document.getElementById(sliderId);
    if (slider) {
      slider.dataset.value = value;
      initSlider(sliderId); // Re-initialize to update visual state
    }
  });

  // Recreate particles based on reset density
  adjustParticleCount(defaultValues.densitySlider);
});

let guiTimeout;
const GUI_FADE_DELAY = 2500; // 2.5 seconds

function resetGuiFade() {
    const gui = document.getElementById('gui');
    gui.classList.remove('fade-out');
    
    // Clear existing timeout
    if (guiTimeout) {
        clearTimeout(guiTimeout);
    }
    
    // Set new timeout
    guiTimeout = setTimeout(() => {
        if (!gui.matches(':hover')) { // Only fade if not being hovered
            gui.classList.add('fade-out');
        }
    }, GUI_FADE_DELAY);
}

// Add event listeners
document.addEventListener('mousemove', resetGuiFade);
document.getElementById('gui').addEventListener('mouseenter', resetGuiFade);

// Initial timeout
resetGuiFade();

// Add with other button listeners
document.getElementById("modeBtn").addEventListener("click", () => {
  if (streamMode === 'all') {
    streamMode = 'recent';
    document.getElementById("modeBtn").textContent = 'Most Recent Valid Data';
  } else {
    streamMode = 'all';
    document.getElementById("modeBtn").textContent = 'Stream All';
  }
});

// Update the handleClickOutside function to handle clicks better
function handleClickOutside(event) {
    const gui = document.getElementById('gui');
    const forecastBtn = document.getElementById('forecastBtn');
    const forecastModal = document.getElementById('forecastModal');
    const plotCanvas = document.getElementById('plotCanvas');
    
    // Ignore clicks on UI elements
    if (gui.contains(event.target) || 
        forecastBtn.contains(event.target) || 
        forecastModal.contains(event.target) ||
        plotCanvas.contains(event.target)) {
        return;
    }

    // Toggle GUI visibility
    if (gui.classList.contains('fade-out')) {
        resetGuiFade();
    } else {
        gui.classList.add('fade-out');
        if (guiTimeout) {
            clearTimeout(guiTimeout);
        }
    }
}

// Add this to the existing event listeners
document.addEventListener('click', handleClickOutside);

// Add these utility functions back
function computeRange(arr) {
    let valid = arr.filter(v => v !== -999.9 && v !== -1e+05);
    if (valid.length === 0) valid = arr; // Fallback if all invalid
    return { min: Math.min(...valid), max: Math.max(...valid) };
}

// Data parsing functions
function parseMagData(lines) {
    // clog("Parsing magnetometer data...");
    let records = [];
    for (let line of lines) {
        if (line.startsWith("#") || line.trim() === "") continue;
        let tokens = line.trim().split(/\s+/);
        if (tokens.length < 13) continue;
        let rec = {
            year: parseInt(tokens[0]), 
            month: parseInt(tokens[1]), 
            day: parseInt(tokens[2]),
            time: tokens[3], 
            julian: parseFloat(tokens[4]), 
            seconds: parseFloat(tokens[5]),
            status: parseInt(tokens[6]), 
            Bx: parseFloat(tokens[7]), 
            By: parseFloat(tokens[8]),
            Bz: parseFloat(tokens[9]), 
            Bt: parseFloat(tokens[10]), 
            Lat: parseFloat(tokens[11]),
            Long: parseFloat(tokens[12])
        };
        records.push(rec);
    }
    // clog("Parsed magnetometer records:", records.length);
    return records;
}

// Add this new function
function updateTemperatureRange(records) {
    if (useDynamicRanges) {
        let validTemps = records.filter(rec => rec.ionTemp !== -1.00e+05).map(rec => rec.ionTemp);
        if (validTemps.length > 0) {
            minTemp = Math.min(...validTemps);
            maxTemp = Math.max(...validTemps);
            // clog("Temperature range updated (dynamic):", minTemp, "to", maxTemp);
        }
    } else {
        minTemp = FIXED_RANGES.TEMPERATURE.min;
        maxTemp = FIXED_RANGES.TEMPERATURE.max;
        // clog("Temperature range set (fixed):", minTemp, "to", maxTemp);
    }
}

// Update the parseSWEData function to use this
function parseSWEData(lines) {
    // clog("Parsing swepam data...");
    let records = [];
    
    for (let line of lines) {
        if (line.startsWith("#") || line.trim() === "") continue;
        let tokens = line.trim().split(/\s+/);
        if (tokens.length < 10) continue;
        records.push({
            year: parseInt(tokens[0]), 
            month: parseInt(tokens[1]), 
            day: parseInt(tokens[2]),
            time: tokens[3], 
            julian: parseFloat(tokens[4]), 
            seconds: parseFloat(tokens[5]),
            status: parseInt(tokens[6]), 
            protonDensity: parseFloat(tokens[7]),
            bulkSpeed: parseFloat(tokens[8]), 
            ionTemp: parseFloat(tokens[9])
        });
    }
    
    updateTemperatureRange(records);
    // clog("Parsed swepam records:", records.length);
    return records;
}

// Add keyboard controls
document.addEventListener('keydown', (event) => {
    // Check if it's the spacebar
    if (event.code === 'Space') {
        // Prevent default spacebar behavior (page scrolling)
        event.preventDefault();
        
        // Toggle play/pause
        playing = !playing;
        if (playing) {
            loop();
            // console.log('%c▶️ Visualization Playing', 'color: #0f0; font-weight: bold;');
        } else {
            noLoop();
            // console.log('%c⏸️ Visualization Paused', 'color: #f90; font-weight: bold;');
        }
    }
});

// Add this function to draw the boundary visualization
function drawBoundary() {
  stroke(0, 204, 255, 50);  // Light blue, semi-transparent
  noFill();
  strokeWeight(1);

  let spawnAreaSize = getSliderValue("spawnSizeSlider");
  let boundaryLimit = getSliderValue("boundarySlider");
  let boundaryAngle = getSliderValue("boundaryAngleSlider");
  let cameraOpening = getSliderValue("cameraOpeningSlider");
  let travelDist = getSliderValue("travelSlider");
  let baseWidth = width * spawnAreaSize / 2;
  
  // Calculate angle-based expansion
  let angleRad = boundaryAngle * PI / 180;
  let tanAngle = tan(angleRad);
  
  // Number of lines in the grid
  let gridLines = 20;
  
  // Draw Z lines (lines going back)
  for (let i = 0; i <= gridLines; i++) {
    let x = map(i, 0, gridLines, -baseWidth * cameraOpening, baseWidth * cameraOpening);
    let xBack = map(i, 0, gridLines, -baseWidth * boundaryLimit, baseWidth * boundaryLimit);
    
    // Add angle-based expansion
    xBack += travelDist * tanAngle * (xBack / (baseWidth * boundaryLimit));
    
    // Left side Z line
    beginShape();
    vertex(x, -baseWidth, 0);
    vertex(xBack, -baseWidth * boundaryLimit, -travelDist);
    endShape();
    
    // Right side Z line
    beginShape();
    vertex(x, baseWidth, 0);
    vertex(xBack, baseWidth * boundaryLimit, -travelDist);
    endShape();
  }
  
  // Draw X lines (horizontal lines)
  for (let i = 0; i <= gridLines; i++) {
    let z = map(i, 0, gridLines, 0, -travelDist);
    let progress = (-z) / travelDist;
    let currentWidth = (baseWidth * cameraOpening) + (baseWidth * (boundaryLimit - cameraOpening) * progress);
    
    // Add angle-based expansion
    let angleExpansion = -z * tanAngle;
    currentWidth += angleExpansion;
    
    beginShape();
    vertex(-currentWidth, -currentWidth, z);
    vertex(currentWidth, -currentWidth, z);
    vertex(currentWidth, currentWidth, z);
    vertex(-currentWidth, currentWidth, z);
    vertex(-currentWidth, -currentWidth, z);
    endShape();
  }
}

// Add this constant near the top of the script section
const SHOW_BOUNDARY_VISUALIZATION = false;  // Set to false to hide boundary grid

// Add event listener for the historical data button
document.getElementById('useHistoricalBtn').addEventListener('click', loadHistoricalData);

// Update the retry button click handler
document.getElementById('retryNowBtn').addEventListener('click', () => {
  retryDelay = 10; // Reset to initial delay
  document.getElementById('countdownNumber').textContent = retryDelay;
  clearInterval(countdownInterval); // Clear existing countdown
  preload(); // Try loading data immediately
});

// Add near the top with other global variables
const FIXED_RANGES = {
  DENSITY: { min: 0.1, max: 6 },       // p/cc
  TEMPERATURE: { min: 10000, max: 300000 }, // K
  SPEED: { min: 250, max: 650 }        // km/s, soft cap
};
let useDynamicRanges = false;  // Default to fixed ranges

// Add new function for data clipping
function clipToRange(value, min, max, softClip = false) {
  if (softClip) {
    // Soft clipping - only apply minimum
    return Math.max(min, value);
  }
  // Hard clipping - apply both min and max
  return Math.max(min, Math.min(max, value));
}

// Update the updateTemperatureRange function
function updateTemperatureRange(records) {
  if (useDynamicRanges) {
    let validTemps = records.filter(rec => rec.ionTemp !== -1.00e+05).map(rec => rec.ionTemp);
    if (validTemps.length > 0) {
      minTemp = Math.min(...validTemps);
      maxTemp = Math.max(...validTemps);
      // clog("Temperature range updated (dynamic):", minTemp, "to", maxTemp);
    }
  } else {
    minTemp = FIXED_RANGES.TEMPERATURE.min;
    maxTemp = FIXED_RANGES.TEMPERATURE.max;
    // clog("Temperature range set (fixed):", minTemp, "to", maxTemp);
  }
}

// Update the data processing in draw()
if (swepamRecords.length > 0) {
  let idx = floor(currentRecordIndex);
  let sweRec = swepamRecords[idx];
  if (sweRec) {
    // Apply clipping to the values
    simSpeed = (sweRec.bulkSpeed !== -9999.9) ? 
      clipToRange(sweRec.bulkSpeed, FIXED_RANGES.SPEED.min, FIXED_RANGES.SPEED.max, true) : currentSpeed;
    
    simDensity = (sweRec.protonDensity !== -9999.9) ? 
      clipToRange(sweRec.protonDensity, FIXED_RANGES.DENSITY.min, FIXED_RANGES.DENSITY.max) : simDensity;
    
    simTemperature = (sweRec.ionTemp !== -1.00e+05) ? 
      clipToRange(sweRec.ionTemp, FIXED_RANGES.TEMPERATURE.min, FIXED_RANGES.TEMPERATURE.max) : currentTemperature;
    
    updateHistory(speedHistory, simSpeed);
    updateHistory(densityHistory, simDensity);
    updateHistory(temperatureHistory, simTemperature);
  }
}

// Then update the data advancement logic to be independent
let lastDataUpdate = 0;

function updateDataStream() {
  if (!playing || totalRecords === 0) return;

  let currentTime = millis();
  let dataRate = getSliderValue("dataRateSlider");
  let updateInterval = 1000 / dataRate; // ms per record

  if (currentTime - lastDataUpdate >= updateInterval) {
    if (streamMode === 'all') {
      currentRecordIndex++;
      if (currentRecordIndex >= totalRecords) currentRecordIndex = 0;
    } else {
      // Find most recent valid data point...
      let idx = totalRecords - 1;
      while (idx > 0 && 
             (magRecords[idx].Bx === -999.9 || 
              magRecords[idx].By === -999.9 || 
              magRecords[idx].Bz === -999.9 || 
              swepamRecords[idx].bulkSpeed === -9999.9 || 
              swepamRecords[idx].protonDensity === -9999.9 || 
              swepamRecords[idx].ionTemp === -1.00e+05)) {
        idx--;
      }
      currentRecordIndex = idx;
    }
    lastDataUpdate = currentTime;
  }
}

// Update the forecast fetch and display code
document.getElementById('forecastBtn').addEventListener('click', () => {
  const modal = document.getElementById('forecastModal');
  const forecastBtn = document.getElementById('forecastBtn');
  
  if (modal.style.display === 'block') {
    modal.style.opacity = '0';
    setTimeout(() => {
      modal.style.display = 'none';
    }, 500);
    forecastBtn.textContent = 'See Forecast';
    return;
  }

  forecastBtn.textContent = 'Hide Forecast';
  
  // Show modal first with opacity 0
  modal.style.display = 'block';
  // Force browser reflow
  modal.offsetHeight;
  // Then fade in
  modal.style.opacity = '1';
  
  // Use cached data
  document.getElementById('forecastTitle').textContent = 'Forecast of Solar and Geomagnetic Activity';
  document.getElementById('forecastDate').textContent = cachedForecastDate || '';
  document.getElementById('forecastContent').innerHTML = `${cachedForecastContent?.trim() || 'Loading forecast data...'}
<h3 style="color: #0cf; opacity: 0.8; font-size: 1.1em; margin-top: 20px; margin-bottom: 10px;">${cachedOutlookTitle || ''}</h3>
<div style="font-size: 1em;">${cachedOutlookContent || ''}</div>
<div style="height: 1px;"></div>`;
});

// Update the X button click handler
document.querySelector('#forecastModal > div').addEventListener('click', () => {
  const modal = document.getElementById('forecastModal');
  modal.style.opacity = '0';
  setTimeout(() => {
    modal.style.display = 'none';
  }, 500);
  document.getElementById('forecastBtn').textContent = 'See Forecast';
});

// Update the outside click handler
document.getElementById('forecastModal').addEventListener('click', (e) => { 
  if (e.target === document.getElementById('forecastModal')) {
    const modal = document.getElementById('forecastModal');
    modal.style.opacity = '0';
    setTimeout(() => {
      modal.style.display = 'none';
    }, 500);
    document.getElementById('forecastBtn').textContent = 'See Forecast';
  }
});

// Add listen button handler
document.getElementById('listenBtn').addEventListener('click', () => {
  window.open('https://www.youtube.com/watch?v=j9A2MTB9gl0', '_blank');
});
</script>
</body>
</html>