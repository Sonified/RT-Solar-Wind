<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ACE 3D Visualization Demo v1.1</title>
  <style>
    /* Basic reset and styling (same as your provided CSS) */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: Arial, sans-serif;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    #gui {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 340px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 10px;
      box-sizing: border-box;
      z-index: 10;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      transition: opacity 0.8s ease-in-out;
    }
    #gui.fade-out {
      opacity: 0;
      pointer-events: none;  /* Prevents interaction while faded out */
    }
    #gui:hover {
      opacity: 1;
      pointer-events: auto;
    }
    #controlsContainer h2 { 
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.2em;
    }
    .control-group {
      margin-bottom: 4px !important;  /* Reduce from 6px to 4px */
    }
    .control-group label { 
      display: block; 
      margin-bottom: 1px;  /* Reduce from 2px to 1px */
      font-size: 0.9em;
    }
    .slider-container {
      position: relative;
      height: 16px;
      background: #333;
      border-radius: 8px;
      cursor: pointer;
    }
    .slider-fill {
      position: absolute;
      height: 100%;
      background: #0cf;
      border-radius: 10px;
      width: 50%; /* Initial fill */
    }
    .slider-value {
      margin-top: 2px;
      text-align: right;
      font-size: 0.8em;
    }
    button {
      width: 100%;
      padding: 6px;
      margin-bottom: 8px;
      background: #0cf;
      border: none;
      border-radius: 5px;
      color: #000;
      font-weight: bold;
      cursor: pointer;
    }
    button:hover { background: #09a; }
    #plotCanvas {
      position: fixed !important;
      top: 25px !important;
      right: 20px !important;
      left: auto !important;
      width: 300px;
      height: 300px;
      background: rgba(0,0,0,0.7);
      border: 2px solid #0cf;
      border-radius: 5px;
      z-index: 10;
      padding: 5px;
      box-sizing: border-box;
    }
    #debug {
      position: fixed;
      bottom: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: #0f0;
      font-family: monospace;
      font-size: 12px;
      padding: 5px;
      max-width: 300px;
      max-height: 200px;
      overflow: auto;
      z-index: 20;
      transition: opacity 0.8s ease-in-out;
    }

    /* Add fade-out behavior for debug window */
    #gui.fade-out ~ #debug {
      opacity: 0;
      pointer-events: none;
    }
    #version-info {
        position: fixed;
        left: 10px;
        bottom: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-family: monospace;
        font-size: 11px;
        z-index: 10;
    }
    
    #creator-info {
        position: fixed;
        left: 220px;  /* Position it to the right of version info */
        bottom: 10px;
        color: rgba(255, 255, 255, 0.5);
        font-family: monospace;
        font-size: 11px;
        z-index: 10;
    }
    #plotTitle {
      position: fixed !important;
      top: 10px !important;
      right: 20px !important;
      color: #0cf;
      font-family: Arial, sans-serif;
      font-size: 14px;
      z-index: 10;
      text-align: center;
      width: 300px;
    }
  </style>
  <script src="p5.min.js"></script>
</head>
<body>
  <div id="gui">
    <div id="controlsContainer">
      <h2>Controls</h2>
      <button id="playBtn">Play</button>
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn">Reset</button>

      <div class="control-group">
        <label>Mode: <button id="modeBtn" style="width: auto; padding: 2px 8px; margin: 0 0 0 8px;">Stream All</button></label>
      </div>

      <div style="height: 10px;"></div>  <!-- Add spacing -->

      <div class="control-group">
        <label>Data Rate</label>
        <div class="slider-container" data-min="0.1" data-max="10" data-step="0.1" data-value="5.00" id="dataRateSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="dataRateSliderValue">5.00/s</div>
      </div>

      <div class="control-group">
        <label>Data Smoothing</label>
        <div class="slider-container" data-min="0" data-max="1" data-step="0.01" data-value="0.90" id="smoothingSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="smoothingSliderValue">90%</div>
      </div>

      <div class="control-group">
        <label>Relative Speed</label>
        <div class="slider-container" data-min="1" data-max="5" data-step="0.1" data-value="1.0" id="relSpeedSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="relSpeedSliderValue">1.0</div>
      </div>
      
      <div class="control-group">
        <label>Speed Data Sensitivity</label>
        <div class="slider-container" data-min="0" data-max="100" data-step="1" data-value="50" id="speedSensitivitySlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="speedSensitivitySliderValue">50%</div>
      </div>

      <div class="control-group">
        <label>Magnetic Field Data Directional Sensitivity</label>
        <div class="slider-container" data-min="0" data-max="100" data-step="1" data-value="100" id="velocitySensitivitySlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="velocitySensitivitySliderValue">100%</div>
      </div>

      <div class="control-group">
        <label>Particle Size</label>
        <div class="slider-container" data-min="1" data-max="20" data-step="1" data-value="15" id="sizeSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="sizeSliderValue">15</div>
      </div>

      <div class="control-group">
        <label>Particle Count</label>
        <div class="slider-container" data-min="1" data-max="500" data-step="1" data-value="120" id="densitySlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="densitySliderValue">120</div>
      </div>

      <div class="control-group">
        <label>Base Generation Rate</label>
        <div class="slider-container" data-min="0" data-max="100" data-step="1" data-value="16" id="genRateSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="genRateSliderValue">16/s</div>
      </div>

      <div class="control-group">
        <label>Travel Distance</label>
        <div class="slider-container" data-min="1000" data-max="5000" data-step="100" data-value="3500" id="travelSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="travelSliderValue">3500</div>
      </div>

      <div class="control-group">
        <label>Spawn Area Size</label>
        <div class="slider-container" data-min="1" data-max="5" data-step="0.1" data-value="3.0" id="spawnSizeSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="spawnSizeSliderValue">3.0</div>
      </div>

      <div class="control-group">
        <label>Motion Trail Length</label>
        <div class="slider-container" data-min="0" data-max="30" data-step="1" data-value="23" id="trailLengthSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="trailLengthSliderValue">23</div>
      </div>

      <div class="control-group">
        <label>Motion Trail Size</label>
        <div class="slider-container" data-min="0" data-max="100" data-step="5" data-value="70" id="trailSizeSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="trailSizeSliderValue">70%</div>
      </div>

      <div class="control-group">
        <label>Fade In Time</label>
        <div class="slider-container" data-min="0.1" data-max="5" data-step="0.1" data-value="1.5" id="fadeInTimeSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="fadeInTimeSliderValue">1.5s</div>
      </div>

      <div class="control-group">
        <label>Motion Trail Size Tapering</label>
        <div class="slider-container" data-min="0" data-max="10" data-step="0.5" data-value="2" id="trailTaperSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="trailTaperSliderValue">2%</div>
      </div>

      <div class="control-group">
        <label>Motion Trail Opacity Tapering</label>
        <div class="slider-container" data-min="0" data-max="100" data-step="5" data-value="85" id="trailOpacityTaperSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="trailOpacityTaperSliderValue">85%</div>
      </div>

      <div class="control-group" style="display: none;">
        <label>Side Boundary</label>
        <div class="slider-container" data-min="0.1" data-max="3.0" data-step="0.1" data-value="0.1" id="boundarySlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="boundarySliderValue">0.1x</div>
      </div>

      <div class="control-group" style="display: none;">
        <label>Boundary Angle</label>
        <div class="slider-container" data-min="0" data-max="45" data-step="1" data-value="44" id="boundaryAngleSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="boundaryAngleSliderValue">44¬∞</div>
      </div>

      <div class="control-group" style="display: none;">
        <label>Camera Opening</label>
        <div class="slider-container" data-min="0.01" data-max="1.0" data-step="0.1" data-value="0.0" id="cameraOpeningSlider">
          <div class="slider-fill"></div>
        </div>
        <div class="slider-value" id="cameraOpeningSliderValue">0.0x</div>
      </div>
    </div>
  </div>

  <div id="plotTitle">ACE Near Real Time Data Stream</div>
  <canvas id="plotCanvas"></canvas>
  <div id="debug"></div>
  <div id="version-info">NOAA ACE Particle Visualization</div>
  <div id="creator-info">Created by Robert Alexander: robert@auralab.io</div>

<script>
// Add this back near the top of the script section
function clog(...args) {
    console.log("debug:", ...args);
}

// ---------- Custom Slider Functions (Reusable) ----------
function initSlider(id) {
  const slider = document.getElementById(id);
  const fill = slider.querySelector('.slider-fill');
  const valueDisplay = document.getElementById(id + "Value");
  const min = parseFloat(slider.dataset.min);
  const max = parseFloat(slider.dataset.max);
  const step = parseFloat(slider.dataset.step);
  let value = parseFloat(slider.dataset.value);

  function updateSlider(newVal) {
    value = Math.min(max, Math.max(min, newVal)); // Clamp value
    slider.dataset.value = value.toFixed(2);
    const percentage = ((value - min) / (max - min)) * 100;
    fill.style.width = percentage + '%';
    
    // Format display value based on slider type
    let displayValue;
    if (id.includes("Sensitivity") || id === "trailSizeSlider" || id === "trailTaperSlider" || id === "trailOpacityTaperSlider") {
      displayValue = Math.round(value) + "%";
    } else if (id === "smoothingSlider") {
      displayValue = Math.round(value * 100) + "%";
    } else if (id === "relSpeedSlider") {
      displayValue = value.toFixed(1);
    } else if (id === "dataRateSlider") {
      displayValue = value.toFixed(2) + "/s";
    } else if (id === "spawnSizeSlider" || id === "boundarySlider" || id === "cameraOpeningSlider") {  // Add cameraOpeningSlider here
      displayValue = value.toFixed(1) + "x";
    } else if (id === "fadeInTimeSlider") {
      displayValue = value.toFixed(1) + "s";
    } else if (id === "genRateSlider") {
      displayValue = Math.round(value) + "/s";
    } else {
      displayValue = Math.round(value);
    }
    valueDisplay.textContent = displayValue;
  }
  updateSlider(value);

  slider.addEventListener('mousedown', (e) => {
    e.preventDefault();
    const rect = slider.getBoundingClientRect();

    function onMove(e) {
      let pos = e.clientX - rect.left;
      let perc = Math.max(0, Math.min(1, pos / rect.width));
      let newVal = min + perc * (max - min);
      newVal = Math.round(newVal / step) * step; // Snap to step
      updateSlider(newVal);
    }

    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    }

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });
}

function getSliderValue(id) {
  return parseFloat(document.getElementById(id).dataset.value);
}


// ---------- Global Variables ----------
let particles = [];
let playing = true;
let currentRecordIndex = 0;

// UI Control Variables (with defaults)
let dataRate;
let relSpeed;
let speedSensitivity;
let velocitySensitivity;
let smoothingFactor;
let particleSize;
let densityFactor;
let travelDistance;
let particleGenRate = 0;
let lastParticleTime = 0;

// Data and Smoothed Parameters
let simDir;
let simSpeed = 1;
let simDensity = 100;
let simTemperature = 0;
let simDateStr = "N/A";
let currentDir;
let currentSpeed = 1;
let currentTemperature = 30000;

// Data Arrays
let magDataRaw = [];
let swepamDataRaw = [];
let magRecords = [];
let swepamRecords = [];
let totalRecords = 0;

// Plotting
let bxHistory = [], byHistory = [], bzHistory = [];
let speedHistory = [];
let densityHistory = [];
let temperatureHistory = [];
const maxHistory = 200;
const plotColors = {
  "Bx": "#0cf", "By": "#fc0", "Bz": "#f0c",
  "Vel": "#0f0", "Dens": "#ff0", "Temp": "#f0f"
};

// Add these global variables
let minTemp, maxTemp;
let spawnAreaSize;
let particlesCreatedTimes = []; // Array to track ALL particle creations (new OR respawn)
const RATE_WINDOW = 50; // 50ms window for rate limiting
let streamMode = 'all'; // 'all' or 'recent'

// Add a new global variable for accumulation
let particleAccumulator = 0;

// Add these global variables
let respawnQueue = [];  // Line of particles waiting to get back in
let nextRespawnTime = 0;

// Add to global variables
let lastRespawnTime = 0;
let respawnInterval = 0;

// Add to global variables
let particlesPassedThisSecond = 0;
let lastCounterReset = 0;

// Replace the spawner with this improved version
let spawner = {
    spawnHistory: [],  // Track spawns in the last second
    lastSpawnTime: 0,  // Track last spawn time
    lastSecondMark: 0, // Track full seconds
    deathCount: 0,     // Track deaths in current second
    
    update() {
        let currentTime = millis();
        let targetRate = getSliderValue("genRateSlider");
        let maxParticles = getSliderValue("densitySlider");
        
        // Check if a full second has passed
        let currentSecond = Math.floor(currentTime/1000);
        let lastSecond = Math.floor(this.lastSecondMark/1000);
        
        if (currentSecond > lastSecond) {
            console.log(`%cüïê ======= NEW SECOND ${currentSecond} =======\n   Active Particles: ${particles.length}/${maxParticles}\n   Spawned: ${this.spawnHistory.length}\n   Deaths: ${this.deathCount}\n   Net Change: ${this.spawnHistory.length - this.deathCount}`, 
                'font-size: 16px; font-weight: bold; color: #0cf;');
            
            // Log all particle positions
            console.log("Particle Positions:");
            particles.forEach((p, i) => {
                clog(`  Particle ${i}: x=${p.pos.x.toFixed(1)}, y=${p.pos.y.toFixed(1)}, z=${p.pos.z.toFixed(1)}`);
            });
            
            this.lastSecondMark = currentTime;
            this.spawnHistory = [];
            this.deathCount = 0;
        }
        
        // Clean history - only keep spawns from last second
        this.spawnHistory = this.spawnHistory.filter(time => 
            currentTime - time < 1000
        );
        
        let minInterval = 1000 / targetRate;
        
        // STRICT particle count enforcement
        if (particles.length >= maxParticles) {
            return; // Don't spawn if we're at or over limit
        }
        
        if (this.spawnHistory.length < targetRate && 
            currentTime - this.lastSpawnTime >= minInterval) {
            
            particles.push(new Particle(getSliderValue("travelSlider")));
            this.spawnHistory.push(currentTime);
            this.lastSpawnTime = currentTime;
            
            clog(`[SPAWN] +1 particle (${particles.length}/${maxParticles}, Rate: ${this.spawnHistory.length}/${targetRate}/s)`);
        }
    }
};

// Modify the existing Particle class update method
class Particle {
  constructor(travelDist) {
    let spawnAreaSize = getSliderValue("spawnSizeSlider");
    this.pos = createVector(
      random(-width * spawnAreaSize / 2, width * spawnAreaSize / 2),
      random(-height * spawnAreaSize / 2, height * spawnAreaSize / 2),
      -travelDist
    );
    this.alpha = 0;
    this.baseVel = createVector(0,0,0);
    this.dataVel = createVector(0,0,0);
    this.birthTime = millis();
    this.birthTemp = simTemperature;
    this.birthDir = currentDir.copy();
    this.birthSpeed = currentSpeed;
    
    // Initialize trail with fixed length (no scaling)
    let maxTrail = getSliderValue("trailLengthSlider");
    this.trail = new Array(Math.round(maxTrail)).fill(this.pos.copy());
  }

  update(dir, speed, relSpeed, speedSens, magFieldSens) {
    // Normal update code...
    this.baseVel = createVector(0, 0, relSpeed * 10);
    this.dataVel = this.birthDir.copy().mult(this.birthSpeed * speedSens * 0.05);
    this.vel = p5.Vector.lerp(this.baseVel, this.dataVel.add(this.baseVel), magFieldSens);
    
    // Update position first
    this.pos.add(this.vel);
    
    // Update trail
    this.trail.push(this.pos.copy());
    while (this.trail.length > getSliderValue("trailLengthSlider")) {
      this.trail.shift();
    }
    
    // Update alpha
    let fadeInTime = getSliderValue("fadeInTimeSlider") * 1000;
    let timeSinceBirth = millis() - this.birthTime;
    this.alpha = map(timeSinceBirth, 0, fadeInTime, 0, 255);
    this.alpha = constrain(this.alpha, 0, 255);

    // Check termination conditions in order
    let travelDist = getSliderValue("travelSlider");
    
    // 1. Check camera plane first
    if (this.pos.z > 5) {
      spawner.deathCount++;
      clog(`[PARTICLE] Terminated at z=${this.pos.z.toFixed(1)} - exceeded camera buffer (5)`);
      return true;
    }
    
    // 2. Check back wall
    if (this.pos.z < -travelDist) {
      spawner.deathCount++;
      clog(`[PARTICLE] Terminated at z=${this.pos.z.toFixed(1)} - exceeded back wall (-${travelDist})`);
      return true;
    }
    
    // 3. Check side boundaries with angle
    let spawnAreaSize = getSliderValue("spawnSizeSlider");
    let boundaryLimit = getSliderValue("boundarySlider");
    let boundaryAngle = getSliderValue("boundaryAngleSlider");
    let cameraOpening = getSliderValue("cameraOpeningSlider");
    let baseWidth = width * spawnAreaSize / 2;
    let progress = (-this.pos.z) / travelDist;
    let angleRad = boundaryAngle * PI / 180;
    let angleExpansion = -this.pos.z * tan(angleRad);
    let currentWidth = (baseWidth * cameraOpening) + (baseWidth * (boundaryLimit - cameraOpening) * progress) + angleExpansion;
    
    if (Math.abs(this.pos.x) > currentWidth || Math.abs(this.pos.y) > currentWidth) {
      spawner.deathCount++;
      clog(`[PARTICLE] Terminated at x=${this.pos.x.toFixed(1)}, y=${this.pos.y.toFixed(1)} - exceeded angled boundary at z=${this.pos.z.toFixed(1)}`);
      return true;
    }
    
    return false;
  }

  reset() {
      let spawnAreaSize = getSliderValue("spawnSizeSlider");
      this.pos = createVector(
          random(-width * spawnAreaSize / 2, width * spawnAreaSize / 2),
          random(-height * spawnAreaSize / 2, height * spawnAreaSize / 2),
          -travelDistance
      );
      this.alpha = 0;
      this.birthTime = millis();
      this.birthTemp = simTemperature;
      this.birthDir = currentDir.copy();  // Update direction on reset
      this.birthSpeed = currentSpeed;
      
      // Clear the trail (no scaling)
      let maxTrail = getSliderValue("trailLengthSlider");
      this.trail = new Array(Math.round(maxTrail)).fill(this.pos.copy());
  }

  show(size) {
      let trailLength = this.trail.length;
      if (trailLength > 0) {
          let trailSizePercent = getSliderValue("trailSizeSlider") / 100;
          let taperPercent = getSliderValue("trailTaperSlider") / 100;
          let opacityTaperPercent = getSliderValue("trailOpacityTaperSlider") / 100;
          
          for (let i = 0; i < trailLength; i++) {
              let pos = this.trail[i];
              if (pos.z > 0) continue;  // Skip if behind camera
              
              let progress = i / trailLength;  // 0 at start, 1 at end
              let trailAlpha = this.alpha * (progress + (1 - opacityTaperPercent));
              let sizeReduction = 1.0 - (taperPercent * (trailLength - i - 1));
              let pointSize = size * trailSizePercent * sizeReduction;
              
              if (pointSize > 0) {
                  push();
                  translate(pos.x, pos.y, pos.z);
                  let col = this.mapTemperatureToColor(this.birthTemp);
                  noStroke();
                  fill(red(col), green(col), blue(col), trailAlpha * 0.5);
                  sphere(pointSize, 3, 3);
                  pop();
              }
          }
      }

      // Draw the main particle if not behind camera
      if (this.pos.z <= 0) {
          push();
          translate(this.pos.x, this.pos.y, this.pos.z);
          let col = this.mapTemperatureToColor(this.birthTemp);
          noStroke();
          fill(red(col), green(col), blue(col), this.alpha);
          sphere(size);
          pop();
      }
  }
    mapTemperatureToColor(temp) {
        let midTemp = minTemp + (maxTemp - minTemp) / 2;
        let col;
        
        if (temp < midTemp) {
            col = lerpColor(
                color(139, 0, 0),    // Dark red for coldest (using RGB values)
                color(0, 0, 255),    // Blue for middle
                map(temp, minTemp, midTemp, 0, 1)
            );
        } else {
            col = lerpColor(
                color(0, 0, 255),    // Blue for middle
                color(255, 255, 255), // White for hottest
                map(temp, midTemp, maxTemp, 0, 1)
            );
        }
        return col;
    }
}

// ---------- Plotting Functions ----------
function updateHistory(arr, value) {
  arr.push(value);
  if (arr.length > maxHistory) arr.shift();
}

function updatePlots() {
  let canvas = document.getElementById("plotCanvas");
  let ctx = canvas.getContext("2d");
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  let numPlots = 6;
  let gap = 5;
  let plotHeight = (canvas.height - (numPlots - 1) * gap) / numPlots;

  drawPlot(ctx, bxHistory, 0, 0 * (plotHeight + gap), canvas.width, plotHeight, "Bx");
  drawPlot(ctx, byHistory, 0, 1 * (plotHeight + gap), canvas.width, plotHeight, "By");
  drawPlot(ctx, bzHistory, 0, 2 * (plotHeight + gap), canvas.width, plotHeight, "Bz");
  drawPlot(ctx, speedHistory, 0, 3 * (plotHeight + gap), canvas.width, plotHeight, "Vel");
  drawPlot(ctx, densityHistory, 0, 4 * (plotHeight + gap), canvas.width, plotHeight, "Dens");
  drawPlot(ctx, temperatureHistory, 0, 5 * (plotHeight + gap), canvas.width, plotHeight, "Temp");
}

function drawPlot(ctx, dataArray, x, y, w, h, label) {
  ctx.fillStyle = "rgba(0,0,0,0.8)";
  ctx.fillRect(x, y, w, h);
  if (dataArray.length < 2) return;

  let range = computeRange(dataArray);
  let minVal = range.min;
  let maxVal = range.max;
  if (maxVal === minVal) { maxVal += 1; minVal -= 1; }

  ctx.strokeStyle = plotColors[label] || "white";
  ctx.lineWidth = 1;
  ctx.beginPath();
  for (let i = 0; i < dataArray.length; i++) {
    let dx = x + (i / (maxHistory - 1)) * w;
    let dy = y + h - ((dataArray[i] - minVal) / (maxVal - minVal)) * h;
    if (i === 0) ctx.moveTo(dx, dy);
    else ctx.lineTo(dx, dy);
  }
  ctx.stroke();

  ctx.fillStyle = plotColors[label] || "white";
  ctx.font = "12px sans-serif";
  ctx.textAlign = "right";  // Right-align the text
  let value = dataArray[dataArray.length-1];
  let text = `${label}: ${label === "Temp" ? value.toFixed(0) : value.toFixed(2)}`;
  ctx.fillText(text, x + w - 5, y + 15);
}

// ---------- Particle Management ----------
function adjustParticleCount(densityFactor) {
    let desiredCount = floor(densityFactor);
    if (desiredCount < particles.length) {
        particles.splice(desiredCount); // Remove excess particles
    }
}

function updateParticles() {
    let currentTime = millis();
    
    // Clean up old creation times more frequently
    particlesCreatedTimes = particlesCreatedTimes.filter(time => 
        currentTime - time < RATE_WINDOW
    );

    // Calculate fractional particles for this window
    let ratePerWindow = (particleGenRate * RATE_WINDOW) / 1000;  // Remove Math.max(1, ...)
    particleAccumulator += ratePerWindow;

    // Only generate if we've accumulated at least one particle
    while (particleGenRate > 0 && 
           particles.length < densityFactor && 
           particleAccumulator >= 1) {
        
        particles.push(new Particle(travelDistance));
        particlesCreatedTimes.push(currentTime);
        particleAccumulator -= 1;  // Subtract one particle worth
    }

    // Update existing particles
    for (let i = particles.length - 1; i >= 0; i--) {
        if (particles[i].update(currentDir, currentSpeed, relSpeed, speedSensitivity, velocitySensitivity)) {
            particles.splice(i, 1);
        }
    }
}

// ---------- p5.js Functions ----------
async function preload() {
  clog("Preloading data files...");
  try {
    // Wait for both files to load
    const [magResponse, swepamResponse] = await Promise.all([
      fetch('https://services.swpc.noaa.gov/text/ace-magnetometer.txt'),
      fetch('https://services.swpc.noaa.gov/text/ace-swepam.txt')
    ]);

    // Get the text from both responses
    const [magText, swepamText] = await Promise.all([
      magResponse.text(),
      swepamResponse.text()
    ]);

    // Parse the data
    magDataRaw = magText.split('\n');
    swepamDataRaw = swepamText.split('\n');
    
    // Parse records immediately
    magRecords = parseMagData(magDataRaw);
    swepamRecords = parseSWEData(swepamDataRaw);
    
    // Update total records
    totalRecords = Math.min(magRecords.length, swepamRecords.length);
    
    // Find first valid record
    for (let i = 0; i < magRecords.length; i++) {
      if (magRecords[i].Bx !== -999.9) {
        currentRecordIndex = i;
        break;
      }
    }

    // Set up auto-refresh
    setInterval(async () => {
      const [newMagResponse, newSwepamResponse] = await Promise.all([
        fetch('https://services.swpc.noaa.gov/text/ace-magnetometer.txt'),
        fetch('https://services.swpc.noaa.gov/text/ace-swepam.txt')
      ]);
      
      const [newMagText, newSwepamText] = await Promise.all([
        newMagResponse.text(),
        newSwepamResponse.text()
      ]);

      magDataRaw = newMagText.split('\n');
      swepamDataRaw = newSwepamText.split('\n');
      magRecords = parseMagData(magDataRaw);
      swepamRecords = parseSWEData(swepamDataRaw);
      totalRecords = Math.min(magRecords.length, swepamRecords.length);
    }, 60000);

  } catch (error) {
    clog("Error in preload:", error);
  }
}

function setup() {
  setAttributes('alpha', true);
  createCanvas(windowWidth, windowHeight, WEBGL);
  frameRate(60);

  // Initialize UI values (important to do this *before* creating particles)
  dataRate = getSliderValue("dataRateSlider");
  relSpeed = getSliderValue("relSpeedSlider");
  speedSensitivity = getSliderValue("speedSensitivitySlider") / 100; // Convert percentage to 0-1 range
  velocitySensitivity = getSliderValue("velocitySensitivitySlider")/100;
  smoothingFactor = getSliderValue("smoothingSlider");
  particleSize = getSliderValue("sizeSlider");
  densityFactor = getSliderValue("densitySlider");
  travelDistance = getSliderValue("travelSlider");
  particleGenRate = getSliderValue("genRateSlider");

  // Print termination conditions
  let cameraBuffer = 5;  // Allow particles to go slightly past camera for trail visibility
  let spawnAreaSize = getSliderValue("spawnSizeSlider");
  let boundaryLimit = getSliderValue("boundarySlider");
  let sideLimit = width * spawnAreaSize * boundaryLimit / 2;
  let travelDist = getSliderValue("travelSlider");
  
  console.log("%c=== Particle Termination Conditions ===", 'font-size: 14px; font-weight: bold; color: #f00;');
  console.log(`Camera Position: (0, 0, 0) looking down -Z axis`);
  console.log(`Spawn Location: x=random(¬±${sideLimit.toFixed(0)}), y=random(¬±${sideLimit.toFixed(0)}), z=${-travelDist} (back wall)`);
  console.log(`Movement Direction: Particles move from back wall (z=${-travelDist}) toward camera (z=0)`);
  console.log(`1. Front wall (camera): z > ${cameraBuffer} units (allows trails to be visible)`);
  console.log(`2. Side boundaries: Angled walls from ¬±${(width * spawnAreaSize/2).toFixed(0)} at camera to ¬±${sideLimit.toFixed(0)} at back (${boundaryLimit}x)`);
  console.log(`3. Back wall: z < ${-travelDist} units (spawn plane)`);
  console.log("=================================");

  // Parse data
  if (magDataRaw && magDataRaw.length > 0) {
    magRecords = parseMagData(magDataRaw);
    for (let i = 0; i < magRecords.length; i++) {
      if (magRecords[i].Bx !== -999.9) {
        currentRecordIndex = i;
        break;
      }
    }
  } else { clog("ERROR: No magnetometer data."); }
  if (swepamDataRaw && swepamDataRaw.length > 0) {
    swepamRecords = parseSWEData(swepamDataRaw);
  } else { clog("ERROR: No swepam data."); }
  totalRecords = min(magRecords.length, swepamRecords.length);
  clog("Total records:", totalRecords);

  currentDir = createVector(1, 0, 0);
  currentSpeed = 1;
  currentTemperature = 30000;

  // Instead of creating all particles at once, start with an empty array
  particles = [];

    // Initialize sliders
    initSlider("dataRateSlider");
    initSlider("relSpeedSlider");
    initSlider("speedSensitivitySlider");
    initSlider("velocitySensitivitySlider");
    initSlider("smoothingSlider");
    initSlider("sizeSlider");
    initSlider("densitySlider");
    initSlider("travelSlider");
    initSlider("genRateSlider");
    initSlider("spawnSizeSlider");
    initSlider("trailLengthSlider");
    initSlider("fadeInTimeSlider");
    initSlider("trailSizeSlider");
    initSlider("trailTaperSlider");
    initSlider("boundarySlider");
    initSlider("boundaryAngleSlider");
    initSlider("cameraOpeningSlider");
    initSlider("trailOpacityTaperSlider");
}


function draw() {
  // Update control variables
  dataRate = getSliderValue("dataRateSlider");
  relSpeed = getSliderValue("relSpeedSlider");
  speedSensitivity = getSliderValue("speedSensitivitySlider") / 100; // 0-1 range
  velocitySensitivity = getSliderValue("velocitySensitivitySlider")/100;
  smoothingFactor = getSliderValue("smoothingSlider");
  particleSize = getSliderValue("sizeSlider");
  densityFactor = getSliderValue("densitySlider");
  travelDistance = getSliderValue("travelSlider");
  particleGenRate = getSliderValue("genRateSlider");

  // Get data for the current frame
  if (magRecords.length > 0) {
    let idx = floor(currentRecordIndex);
    let magRec = magRecords[idx];
    if (magRec) {
      let bx = (magRec.Bx !== -999.9) ? magRec.Bx : currentDir.x;
      let by = (magRec.By !== -999.9) ? magRec.By : currentDir.y;
      let bz = (magRec.Bz !== -999.9) ? magRec.Bz : currentDir.z;
      simDir = createVector(bx, by, bz).normalize();
      simDateStr = nf(magRec.year, 4) + "-" + nf(magRec.month, 2) + "-" + nf(magRec.day, 2) + " " + magRec.time;
      updateHistory(bxHistory, bx);
      updateHistory(byHistory, by);
      updateHistory(bzHistory, bz);
    }
  }
  if (swepamRecords.length > 0) {
    let idx = floor(currentRecordIndex);
    let sweRec = swepamRecords[idx];
    if (sweRec) {
        simSpeed = (sweRec.bulkSpeed !== -9999.9) ? sweRec.bulkSpeed : currentSpeed;
        simDensity = (sweRec.protonDensity !== -9999.9) ? sweRec.protonDensity : simDensity;
        simTemperature = (sweRec.ionTemp !== -1.00e+05) ? sweRec.ionTemp : currentTemperature;
        
        updateHistory(speedHistory, simSpeed);
        updateHistory(densityHistory,simDensity);
        updateHistory(temperatureHistory, simTemperature);
    }
  }

  // Smoothing
  let updateFactor = lerp(1, 0.05, smoothingFactor);
  currentDir = p5.Vector.lerp(currentDir, simDir, updateFactor);
  currentSpeed = lerp(currentSpeed, simSpeed, updateFactor);
  currentTemperature = lerp(currentTemperature, simTemperature, smoothingFactor);

  // Adjust particle count
  adjustParticleCount(densityFactor);

  // Update and draw particles
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    
    // Update particle
    if (p.update(currentDir, currentSpeed, relSpeed, speedSensitivity, velocitySensitivity)) {
        particles.splice(i, 1);  // Remove if update returns true
        continue;
    }
    
    // Draw particle
    p.show(particleSize);
  }

  // Generate new particles based on rate
  spawner.update();

  // p5.js drawing
  background(0);
  camera(0, 0, 0, 0, 0, -1000, 0, 1, 0); // Look down -Z axis

  // Advance record index (if playing)
  if (playing && totalRecords > 0) {
    if (streamMode === 'all') {
      currentRecordIndex += dataRate / 60.0; // Assuming ~60fps
      if (currentRecordIndex >= totalRecords) currentRecordIndex = 0;
    } else {
      // Find most recent valid data point
      let idx = totalRecords - 1;
      while (idx > 0 && 
             (magRecords[idx].Bx === -999.9 || 
              magRecords[idx].By === -999.9 || 
              magRecords[idx].Bz === -999.9 || 
              swepamRecords[idx].bulkSpeed === -9999.9 || 
              swepamRecords[idx].protonDensity === -9999.9 || 
              swepamRecords[idx].ionTemp === -1.00e+05)) {
        idx--;
      }
      currentRecordIndex = idx;
    }
  }

  // Update and draw particles with rate-limited respawning
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    
    // Check if particle needs to reset
    if (p.pos.z >= travelDistance) {  // Particle hit the far camera plane
        particles.splice(i, 1);
        clog(`Removed particle at camera plane (Count: ${particles.length})`);
    } else {
      p.show(particleSize);
    }
  }
    updatePlots(); // Update the plots.

  // Replace the existing debug logging with more detailed particle system status
  if (frameCount % 100 === 0) {
    clog("=== Particle System Status ===");
    clog(`Generation Rate: ${particleGenRate} particles/sec`);
    clog(`Current Particle Count: ${particles.length}`);
    clog(`Target Count: ${densityFactor}`);
    clog(`Last Generation: ${millis() - lastParticleTime}ms ago`);
    clog(`Current Frame: ${frameCount}`);
    clog(`Record: ${floor(currentRecordIndex)} Date: ${simDateStr}`);
    clog("===========================");
  }

    let dbgText = "Frame: " + frameCount + "<br>" +
        "Record: " + floor(currentRecordIndex) + " / " + totalRecords + "<br>" +
        "Date/Time: " + simDateStr + " (UTC)<br>" +
        "Bx, By, Bz: " + ((magRecords.length > 0 && magRecords[floor(currentRecordIndex)]) ?
            magRecords[floor(currentRecordIndex)].Bx.toFixed(2) + ", " +
            magRecords[floor(currentRecordIndex)].By.toFixed(2) + ", " +
            magRecords[floor(currentRecordIndex)].Bz.toFixed(2) : "N/A") + "<br>" +
        "Bulk Speed: " + simSpeed.toFixed(2) + "<br>" +
        "Density: " + simDensity.toFixed(2) + "<br>" +
        "Ion Temp: " + simTemperature.toFixed(2) + "<br>" +
        "Data Rate: " + dataRate.toFixed(2) + " rec/sec, Rel Speed: " + relSpeed.toFixed(2) + "<br>" +
        "Speed Sens: " + (speedSensitivity * 100).toFixed(0) + "%, Mag Field Sens: " + (velocitySensitivity*100).toFixed(0) + "%<br>"+
        "Smoothing: " + smoothingFactor.toFixed(2) + ", Particle Size: " + particleSize.toFixed(2) + "<br>" +
        "Active Particles: " + particles.length + "<br>";

    document.getElementById("debug").innerHTML = dbgText;

  if (SHOW_BOUNDARY_VISUALIZATION) {
    drawBoundary();  // Only draw boundary if enabled
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight, WEBGL);
  clog("Window resized:", windowWidth, windowHeight);
}

// ---------- UI Button Listeners ----------
document.getElementById("playBtn").addEventListener("click", () => {
  playing = true;
  loop();
});
document.getElementById("pauseBtn").addEventListener("click", () => {
  playing = false;
  noLoop();
});
document.getElementById("resetBtn").addEventListener("click", () => {
  particles = []; // Clear particles
  currentRecordIndex = 0; // Reset to start
  adjustParticleCount(getSliderValue("densitySlider")); // Recreate based on current density
  // Reset other parameters to their initial states if needed
  currentDir = createVector(1,0,0);
  currentSpeed = 1;
  currentTemperature = 30000;
});

let guiTimeout;
const GUI_FADE_DELAY = 2500; // 2.5 seconds

function resetGuiFade() {
    const gui = document.getElementById('gui');
    gui.classList.remove('fade-out');
    
    // Clear existing timeout
    if (guiTimeout) {
        clearTimeout(guiTimeout);
    }
    
    // Set new timeout
    guiTimeout = setTimeout(() => {
        if (!gui.matches(':hover')) { // Only fade if not being hovered
            gui.classList.add('fade-out');
        }
    }, GUI_FADE_DELAY);
}

// Add event listeners
document.addEventListener('mousemove', resetGuiFade);
document.getElementById('gui').addEventListener('mouseenter', resetGuiFade);

// Initial timeout
resetGuiFade();

// Add with other button listeners
document.getElementById("modeBtn").addEventListener("click", () => {
  if (streamMode === 'all') {
    streamMode = 'recent';
    document.getElementById("modeBtn").textContent = 'Most Recent Valid Data';
  } else {
    streamMode = 'all';
    document.getElementById("modeBtn").textContent = 'Stream All';
  }
});

// Add this function near the other GUI fade functions
function handleClickOutside(event) {
    const gui = document.getElementById('gui');
    if (gui.classList.contains('fade-out')) {
        // If controls are hidden, show them (unless clicking on controls)
        if (!gui.contains(event.target)) {
            resetGuiFade();
        }
    } else {
        // If controls are visible, hide them when clicking outside
        if (!gui.contains(event.target)) {
            gui.classList.add('fade-out');
            if (guiTimeout) {
                clearTimeout(guiTimeout);
            }
        }
    }
}

// Add this to the existing event listeners
document.addEventListener('click', handleClickOutside);

// Add these utility functions back
function computeRange(arr) {
    let valid = arr.filter(v => v !== -999.9 && v !== -1e+05);
    if (valid.length === 0) valid = arr; // Fallback if all invalid
    return { min: Math.min(...valid), max: Math.max(...valid) };
}

// Data parsing functions
function parseMagData(lines) {
    clog("Parsing magnetometer data...");
    let records = [];
    for (let line of lines) {
        if (line.startsWith("#") || line.trim() === "") continue;
        let tokens = line.trim().split(/\s+/);
        if (tokens.length < 13) continue;
        let rec = {
            year: parseInt(tokens[0]), 
            month: parseInt(tokens[1]), 
            day: parseInt(tokens[2]),
            time: tokens[3], 
            julian: parseFloat(tokens[4]), 
            seconds: parseFloat(tokens[5]),
            status: parseInt(tokens[6]), 
            Bx: parseFloat(tokens[7]), 
            By: parseFloat(tokens[8]),
            Bz: parseFloat(tokens[9]), 
            Bt: parseFloat(tokens[10]), 
            Lat: parseFloat(tokens[11]),
            Long: parseFloat(tokens[12])
        };
        records.push(rec);
    }
    clog("Parsed magnetometer records:", records.length);
    return records;
}

function parseSWEData(lines) {
    clog("Parsing swepam data...");
    let records = [];
    let validTemps = [];
    
    for (let line of lines) {
        if (line.startsWith("#") || line.trim() === "") continue;
        let tokens = line.trim().split(/\s+/);
        if (tokens.length < 10) continue;
        let rec = {
            year: parseInt(tokens[0]), 
            month: parseInt(tokens[1]), 
            day: parseInt(tokens[2]),
            time: tokens[3], 
            julian: parseFloat(tokens[4]), 
            seconds: parseFloat(tokens[5]),
            status: parseInt(tokens[6]), 
            protonDensity: parseFloat(tokens[7]),
            bulkSpeed: parseFloat(tokens[8]), 
            ionTemp: parseFloat(tokens[9])
        };
        
        // Collect valid temperature readings
        if (rec.ionTemp !== -1.00e+05) {
            validTemps.push(rec.ionTemp);
        }
        
        records.push(rec);
    }
    
    // Calculate temperature range from valid readings
    if (validTemps.length > 0) {
        minTemp = Math.min(...validTemps);
        maxTemp = Math.max(...validTemps);
        clog("Temperature range:", minTemp, "to", maxTemp);
    }
    
    clog("Parsed swepam records:", records.length);
    return records;
}

// Add keyboard controls
document.addEventListener('keydown', (event) => {
    // Check if it's the spacebar
    if (event.code === 'Space') {
        // Prevent default spacebar behavior (page scrolling)
        event.preventDefault();
        
        // Toggle play/pause
        playing = !playing;
        if (playing) {
            loop();
            console.log('%c‚ñ∂Ô∏è Visualization Playing', 'color: #0f0; font-weight: bold;');
        } else {
            noLoop();
            console.log('%c‚è∏Ô∏è Visualization Paused', 'color: #f90; font-weight: bold;');
        }
    }
});

// Add this function to draw the boundary visualization
function drawBoundary() {
  stroke(0, 204, 255, 50);  // Light blue, semi-transparent
  noFill();
  strokeWeight(1);

  let spawnAreaSize = getSliderValue("spawnSizeSlider");
  let boundaryLimit = getSliderValue("boundarySlider");
  let boundaryAngle = getSliderValue("boundaryAngleSlider");
  let cameraOpening = getSliderValue("cameraOpeningSlider");
  let travelDist = getSliderValue("travelSlider");
  let baseWidth = width * spawnAreaSize / 2;
  
  // Calculate angle-based expansion
  let angleRad = boundaryAngle * PI / 180;
  let tanAngle = tan(angleRad);
  
  // Number of lines in the grid
  let gridLines = 20;
  
  // Draw Z lines (lines going back)
  for (let i = 0; i <= gridLines; i++) {
    let x = map(i, 0, gridLines, -baseWidth * cameraOpening, baseWidth * cameraOpening);
    let xBack = map(i, 0, gridLines, -baseWidth * boundaryLimit, baseWidth * boundaryLimit);
    
    // Add angle-based expansion
    xBack += travelDist * tanAngle * (xBack / (baseWidth * boundaryLimit));
    
    // Left side Z line
    beginShape();
    vertex(x, -baseWidth, 0);
    vertex(xBack, -baseWidth * boundaryLimit, -travelDist);
    endShape();
    
    // Right side Z line
    beginShape();
    vertex(x, baseWidth, 0);
    vertex(xBack, baseWidth * boundaryLimit, -travelDist);
    endShape();
  }
  
  // Draw X lines (horizontal lines)
  for (let i = 0; i <= gridLines; i++) {
    let z = map(i, 0, gridLines, 0, -travelDist);
    let progress = (-z) / travelDist;
    let currentWidth = (baseWidth * cameraOpening) + (baseWidth * (boundaryLimit - cameraOpening) * progress);
    
    // Add angle-based expansion
    let angleExpansion = -z * tanAngle;
    currentWidth += angleExpansion;
    
    beginShape();
    vertex(-currentWidth, -currentWidth, z);
    vertex(currentWidth, -currentWidth, z);
    vertex(currentWidth, currentWidth, z);
    vertex(-currentWidth, currentWidth, z);
    vertex(-currentWidth, -currentWidth, z);
    endShape();
  }
}

// Add this constant near the top of the script section
const SHOW_BOUNDARY_VISUALIZATION = false;  // Set to false to hide boundary grid
</script>
</body>
</html>